#  上古神器Pwnkit提权检测：如何排除它的踪迹，守护系统安全（CVE-2021-4034）   
原创 爱坤  爱坤sec   2025-03-29 16:24  
  
什么是 pkexec  
？  
  
Linux 中有个工具叫 pkexec  
 ，它的作用是允许普通用户以管理员（root）身份运行命令。这就像是你找到了一个有管理员权限的钥匙，能打开很多权限受  
  
限的大门。  
  
不过，pkexec  
 需要一个前提：你必须通过验证，像是输入密码什么的。但问题就在这里，pwnkit  
 这个漏洞就是利用了 pkexec  
 的一个弱点。  
  
漏洞的原理  
  
假设 pkexec  
 就是一个派对的门卫，他负责决定谁可以进门，谁不能。但是，门卫有一个问题——他在检查你的“身份证”时，忽略了一个关键环节。他没注意到你的身份证上的某些信息是错误的，这给了你一个小漏洞，可以趁机混进去。  
  
而这个小漏洞，就是 pwnkit  
 利用的。具体来说，漏洞发生的地方是，pkexec  
 会依赖一个名为 SHELL  
 的环境变量来决定你想用什么命令行工具来运行命令。正常情况下，它会检查一下你指定的 SHELL  
 变量是否合法，比如 /bin/bash  
 这样的路径，但 pwnkit  
 漏洞让这个检查变得脆弱，攻击者可以用一些特殊的方式修改这个 SHELL  
 变量。  
  
攻击过程  
  
**(1)环境变量的修改**  
：攻击者通过修改环境变量，特别是 SHELL  
 变量，指定了一个不存在的路径。比如，它设置 SHELL=/lol/i/do/not/exists  
（你可以理解为写了一个乱七八糟的名字，门卫竟然没看出来）。****  
  
**(2)加载恶意代码**  
：然后，攻击者指定了一个本地路径 GCONV_PATH=./pwnkit.so  
，这个路径其实是攻击者自己放置的恶意共享库（也就是伪装的工具箱）。它会被加载并执行，从而触发漏洞，允许攻击者获得 root 权限。****  
  
**(3)提权成功**  
：由于 pkexec  
 对环境变量的检查不严格，攻击者就能借机利用漏洞，绕过验证，以管理员身份执行命令。这样，攻击者就像是偷偷拿到了系统的管理员权限钥匙，轻松地就成为了 root 用户。  
  
简单来说，pwnkit  
 就是通过修改一些环境变量，伪装成合法的请求，绕过了 pkexec  
 的安全检查，从而获得了 root 权限。就像是找到了一扇门后门，轻松进入了一个本来应该是封闭的区域。  
  
  
如何查看是否可以通过Pwnkit神器进行提权  
  
1.直接查看pkexec版本来确定  
```
pkexec --version
```  
  
如果版本小于0.113，那就大概率会被影响  
  
如何你的机器的pkexec是符合要求的，又怀疑被人留下了奇怪的痕迹，那怎么判断是否是通过Pwnkit进行提权的  
  
1.首先看日志  
  
检查 /var/log/auth.log  
 认证日志  
  
pkexec运行时会在 **/var/log/auth.log**  
（Ubuntu/Debian）或 **/var/log/secure**  
（CentOS）留下认证记录。你可以使用以下命令查找可疑行为：  
```
sudo grep 'pkexec' /var/log/auth.log
```  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/pRXeQadBtYHfaXX9icWHBGRrsOsoMgdM6ibsL3Oem9opZFIDHibGQmmKP9JtibTLOjNQ4WmmZ6vUhFQhP2qq2MqPBg/640?wx_fmt=png&from=appmsg "")  
  
日志表示已经通过使用Pwnkit神器进行提权了  
```
Mar 29 07:00:44 ubuntu pkexec[4491]: ubuntu: The value for the SHELL variable was not found the /etc/shells file [USER=root] [TTY=/dev/pts/0] [CWD=/tmp/CVE-2021-4034-main] [COMMAND=GCONV_PATH=./pwnkit.so:. PATH=GCONV_PATH=. SHELL=/lol/i/do/not/exists CHARSET=PWNKIT GIO_USE_VFS=]
```  
  
pkexec 以 root 身份执行了（USER=root）。  
  
CWD=/tmp/CVE-2021-4034-main，说明攻击者在 /tmp/CVE-2021-4034-main 目录运行了 PwnKit 的 PoC。  
  
GCONV_PATH=./pwnkit.so:.，这和 PwnKit 利用手法完全一致，说明攻击者尝试利用恶意 GCONV 模块进行提权。  
  
SHELL=/lol/i/do/not/exists，这是 PwnKit 漏洞常见的 SHELL 变量伪造方式，用于绕过 pkexec 的参数校验。  
  
多次重复执行，从 07:00:44 到 07:17:28，说明攻击者可能在不断尝试获取 root shell。  
  
  
检查服务日志  
```
journalctl | grep pkexec
```  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/pRXeQadBtYHfaXX9icWHBGRrsOsoMgdM6Vj8Uh4EbGmJOgPuqM3Bm7iakfyJt4rYGgic1dfQF42SOibWYRuVFaGsDw/640?wx_fmt=png&from=appmsg "")  
  
这条日志表明 pkexec  
 正在执行，且试图运行一个不在 /etc/shells  
 文件中的 SHELL /lol/i/do/not/exists  
。这表明攻击者可能已经修改了环境变量，以利用 pwnkit  
 漏洞进行提权。  
```
Mar 29 07:00:44 ubuntu pkexec[4491]: ubuntu: The value for the SHELL variable was not found the /etc/shells file [USER=root] [TTY=/dev/pts/0] [CWD=/tmp/CVE-2021-4034-main] [COMMAND=GCONV_PATH=./pwnkit.so:. PATH=GCONV_PATH=. SHELL=/lol/i/do/not/exists CHARSET=PWNKIT GIO_USE_VFS=]
```  
  
从日志来看，pkexec  
 被多次执行，且每次执行时都带有一些特殊的环境变量，这些变量表明攻击者可能正在尝试利用 pwnkit  
 漏洞进行提权。具体来说，以下几点值得注意：  
  
**环境变量分析：**  
  
**SHELL=/lol/i/do/not/exists: SHELL 变量指向一个不存在的路径，这是攻击者利用漏洞的一种方式，可能在为提权操作准备特定环境。**  
  
**GCONV_PATH=./pwnkit.so: 指定了一个本地的共享库 pwnkit.so，这通常与 pwnkit 漏洞的利用方法相关，可能是攻击者尝试加载自己的恶意代码。**  
  
**CHARSET=PWNKIT: 设置字符集为 PWNKIT，这也是漏洞利用的一部分。**  
  
**GIO_USE_VFS=: 可能是尝试影响 GIO 库的行为，进一步操控权限。**  
  
如果这是正常的操作日志，应该不会有如此频繁的尝试，尤其是带有异常环境变量的。  
  
我们来检查是否提权成功了  
  
查看 UID/GID：  
检查 pkexec  
 执行时的 UID 是否为 root（UID 0），如果是，说明提权成功  
```
ps aux | grep pkexec
```  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/pRXeQadBtYHfaXX9icWHBGRrsOsoMgdM6kZ9dVMmeqY7yvaFm0UbiaialRcTc4Tltgx5P57saDvGex0KPxkicNZTEA/640?wx_fmt=png&from=appmsg "")  
  
查看 /proc  
 目录下的进程：如果 pkexec 成功提权，可能会有一个以 root 身份运行的进程。你可以查看该进程的信息。  
```
ps -ef | grep pkexec
```  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/pRXeQadBtYHfaXX9icWHBGRrsOsoMgdM6MZM5Q6Ij8cNB72gvDAS2nLoUsHeLj3pFmBz6NlibT7ibl1ibjCfHUB3Qg/640?wx_fmt=png&from=appmsg "")  
  
  
2.怎么判断辣个男人还在线![](https://res.wx.qq.com/t/wx_fed/we-emoji/res/assets/newemoji/Yellowdog.png "")  
  
  
这里我直接列出所有的活动的shell  
```
ps aux | grep 'bash\|sh\|zsh\|pkexec'
```  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/pRXeQadBtYHfaXX9icWHBGRrsOsoMgdM65k1X49umZwpGKhSib22v0tic5g2CfRBw10QF8h4SxHyqXdo5ibLhSKBXw/640?wx_fmt=png&from=appmsg "")  
  
这里可以看到有一个id为1028的远程终端，并且运行该进程的用户为root  
  
我们这里查看进程的详细详细  
```
# ls -l /proc/1028/exe
lrwxrwxrwx 1 root root 0 Mar 29 07:36 /proc/1028/exe -> /usr/bin/dash
# cat /proc/1028/cmdline
/bin/sh
#
```  
  
我们发现这个**进程连接到 /usr/bin/dash**  
，而不是默认的 /bin/bash  
，说明这个 shell 可能是在攻击者利用某个漏洞时创建的，而非正常操作。  
  
我们来查看是谁在使用这个sh？  
  
使用命令  
```
ps -fp 1028
```  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/pRXeQadBtYHfaXX9icWHBGRrsOsoMgdM6U1h29j4qS3qSZz2UHRlxvyYc2kg3MgibhJHEh3CnNbjTib68TWicbbZ7Q/640?wx_fmt=png&from=appmsg "")  
  
我们发现其父id是ubuntu用户的，我们通过auth日志发现，我们的ubuntu用户是通过ssh登录的  
```
grep 'ubuntu' /var/log/auth.log
```  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/pRXeQadBtYHfaXX9icWHBGRrsOsoMgdM6Z7ATydmk59NYdGxyG0D6BvUssBGDTJ0iaWxcjukPY9MJZl2nfzp6IkQ/640?wx_fmt=png&from=appmsg "")  
  
  
