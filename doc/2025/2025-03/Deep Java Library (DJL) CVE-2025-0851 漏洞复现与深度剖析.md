#  Deep Java Library (DJL) CVE-2025-0851 漏洞复现与深度剖析   
原创 HSCERT  山石网科安全技术研究院   2025-03-16 09:03  
  
![图片](https://mmbiz.qpic.cn/sz_mmbiz_gif/NGIAw2Z6vnLzibrp7C4HmazCNIQXMJIRxvbibNMMmxDGrTN0Z9ibYzXnSNKobTzADCPgdo1b7ukKNARFEicHqQiajWw/640?wx_fmt=gif&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1&tp=webp "")  
  
![图片](https://mmbiz.qpic.cn/mmbiz_png/NGIAw2Z6vnLSsTccx7j0fJVU0OOoqKA8Jb8ZACqDjPdMzgicp2SzdZ19mFnVcBO53s1uA2cSfarQkwibVUeCeH9w/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1&tp=webp "")  
  
  
****  
****  
**Java开发者注意！DJL框架中的一个漏洞可能让你的服务器面临被攻击的风险！**  
  
****  
****  
![图片](https://mmbiz.qpic.cn/mmbiz_jpg/NGIAw2Z6vnLKuKAwMiaYedpTAYugKibaTBsHzf5pDuztECgfIgOfpG5DRF31jzhosMEj23dlx186q0zgLaIZj9lA/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1&tp=webp "")  
  
  
  
在当今数字化时代，深度学习框架的安全性至关重要。然而，即使是备受开发者青睐的开源框架也可能隐藏着潜在的安全漏洞。最近，Deep Java Library（DJL）被曝出存在一个严重的路径遍历漏洞（CVE-2025-0851），这一问题可能让攻击者有机会在目标系统中执行恶意操作。今天，我们就来深入剖析这个漏洞的细节，探讨其危害以及如何有效防范。  
  
  
![图片](https://mmbiz.qpic.cn/mmbiz_png/NGIAw2Z6vnLSsTccx7j0fJVU0OOoqKA8lvpAJHElQA6DiaJniaZb0daO3Kppz9ndV9Z2hHsjMuH61r2hu0jesGSg/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1&tp=webp "")  
  
**一、漏洞描述**  
  
  
Deep Java Library（DJL）是一个开源的、高级的、引擎无关的Java深度学习框架。DJL旨在让Java开发者易于上手和使用。DJL提供了原生的Java开发体验，并且像其他常规Java库一样运作（**AWS**开源项目）。并且，DJL提供了用于提取tar和zip模型归档的工具，这些归档在加载模型以供DJL使用时会用到。发现这些工具存在问题，未能在提取过程中防止**绝对路径遍历**。  
  
  
**Deep Java Library (DJL}**  
[1]  
 is an open-source, high-level, engine-agnostic Java framework for   
deep learning. DJL is designed to be easy to get started with and simple to use for Java developers. DJL provides a native Java development experience and functions like any other   
regular Java library.  
  
  
DJL provides utilities for extracting tar and zip model archives that are used when loading   
models for use with DJL. These utilities were found to contain issues that do not protect against absolute path traversal during the extraction process.  
[2]  
  
  
![图片](https://mmbiz.qpic.cn/mmbiz_png/NGIAw2Z6vnLSsTccx7j0fJVU0OOoqKA8lvpAJHElQA6DiaJniaZb0daO3Kppz9ndV9Z2hHsjMuH61r2hu0jesGSg/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1&tp=webp "")  
  
**二、漏洞条件**  
  
- 版本<0.31.1  
  
- 压缩包的创建和解压，分别在**默认分隔符不同**的操作系统（Windows/Linux）进行  
  
  
  
![图片](https://mmbiz.qpic.cn/mmbiz_png/NGIAw2Z6vnLSsTccx7j0fJVU0OOoqKA8lvpAJHElQA6DiaJniaZb0daO3Kppz9ndV9Z2hHsjMuH61r2hu0jesGSg/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1&tp=webp "")  
  
**三、漏洞定位**  
  
  
```
ai.djl.util.TarUtils#untar

```  
  
  
  
```
ublic static void untar(InputStream is, Path dir, boolean gzip) throws IOException {
        InputStream bis;
        if (gzip) {
            bis = new GzipCompressorInputStream(new BufferedInputStream(is));
       } else {
            bis = new BufferedInputStream(is);
       }
        bis = CloseShieldInputStream.wrap(bis);
        try (TarArchiveInputStream tis = new TarArchiveInputStream(bis)) {
            TarArchiveEntry entry;
            while ((entry = tis.getNextEntry()) != null) {
                String entryName = 
ZipUtils.removeLeadingFileSeparator(entry.getName());
                if (entryName.contains("..")) {
                    throw new IOException("Malicious zip entry: " + entryName);
               }
               Path file = dir.resolve(entryName).toAbsolutePath();
                if (entry.isDirectory()) {
                    Files.createDirectories(file);
               } else {
                    Path parentFile = file.getParent();
                    if (parentFile == null) {
                        throw new AssertionError("Parent path should never be null: " + file);
                   }
                    Files.createDirectories(parentFile);
                    Files.copy(tis, file, StandardCopyOption.REPLACE_EXISTING);
               }
           }
       }
   }

```  
  
  
  
  
![图片](https://mmbiz.qpic.cn/mmbiz_png/NGIAw2Z6vnLSsTccx7j0fJVU0OOoqKA8lvpAJHElQA6DiaJniaZb0daO3Kppz9ndV9Z2hHsjMuH61r2hu0jesGSg/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1&tp=webp "")  
  
**四、漏洞详情**  
  
****  
  
**（一）环境配置**  
  
![图片](https://mmbiz.qpic.cn/mmbiz_png/NGIAw2Z6vnLSsTccx7j0fJVU0OOoqKA8WFHRW8Evk0zcqAPJSmSRktqm69UXCNGtz8L1sz1g1Wg3sEYViamG90Q/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1&tp=webp "")  
  
  
首先，引入  
maven  
依赖[2]  
：  
Maven Repository: ai.djl » api » 0.31.0   
  
  
![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnTzTK15lSh9yySicgYfpKWusWLgI4dlKO8uhyX27bicUYQX5tMSb04Z7ZhCLhrNrKDVw9iae1FNQeH2A/640?wx_fmt=png&from=appmsg "")  
  
  
  
接着，  
创建访问点：  
  
```
import ai.djl.util.TarUtils;
@PostMapping("/CVE-2025-0851")
    public void CVE20250851(@RequestParam MultipartFile file, @RequestParam boolean gzip) {
        try{
            InputStream fis = file.getInputStream();
 //这里只关系根路径"C:/"即可，anyPath可以是任意路径
            Path base = Paths.get("C:/anyPath");
            TarUtils.untar(fis,base,gzip);
       }catch (Exception e){
       e.printStackTrace();
       }
   }

```  
  
  
  
并且，  
在  
Kali中创建恶意tar包。  
  
  
![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnTzTK15lSh9yySicgYfpKWus7shAgqaqjJPz3b3glE9OJ1lypQxmpzlhwF5ldxMWXlRpibR7AhX0GMg/640?wx_fmt=png&from=appmsg "")  
  
  
![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnTzTK15lSh9yySicgYfpKWuszy3x4s2jA78rMUGLykUZOI9ByqrkYbAjwatC190F0QZJd6NMvBrOSQ/640?wx_fmt=png&from=appmsg "")  
  
  
  
此时Windows对应路径：  
  
  
![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnTzTK15lSh9yySicgYfpKWus49OwCceqkLA9ho9wH3znI9iaicNyu7TTSbibjebkVO2zicicamXl4BuuZDg/640?wx_fmt=png&from=appmsg "")  
  
  
  
**（二）测试**  
  
![图片](https://mmbiz.qpic.cn/mmbiz_png/NGIAw2Z6vnLSsTccx7j0fJVU0OOoqKA8WFHRW8Evk0zcqAPJSmSRktqm69UXCNGtz8L1sz1g1Wg3sEYViamG90Q/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1&tp=webp "")  
  
第一步  
  
**使用curl访问测试点**  
：  
  
```
curl -X POST -F "file=@hack.tar" -F "gzip=false" 
http://192.168.23.1:8081/CVE-2025-0851

```  
  
  
  
![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnTzTK15lSh9yySicgYfpKWusMNFOxBIwXpmiaYicv1SCCr5N9h5mib0sPkqR1YAzhhCaTNmF51XVfTheA/640?wx_fmt=png&from=appmsg "")  
  
  
进入untar(...):发现获取到entry.name 的分隔符是/，与上述内容一致。  
  
  
![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnTzTK15lSh9yySicgYfpKWusfABYJ02MXqmf05auZhFpndN6RC5yq9XWqAEqvXibaWqfy0I6yu2Gtibg/640?wx_fmt=png&from=appmsg "")  
  
  
进入removeLeadingFileSeparator(...)：windows操作系统的分隔符是**\**，从而绕过检测。  
  
  
![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnTzTK15lSh9yySicgYfpKWusObWAk0xXCAs7YqtTkaVgjkndldPN4oETJiaPFXLcwKfePiaDsTQrL7ag/640?wx_fmt=png&from=appmsg "")  
  
  
  
回到untar:发现生成的最终绝对路径与 anyPath 无关，只和root和entryName有关  
;这是因为当entryName中开头**存在分隔符**时dir.resolve(entryName).toAbsolutePath()会将entryName识别成“绝对路径”，所以会和dir.root("C:\")拼接。若开头**不存在分隔符**则会被识别成“相对路径”，会和dir.path拼接。  
  
  
![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnTzTK15lSh9yySicgYfpKWusibe9FkGhrx2QjgREwVZV1WbB4wI6fHLZdQLBdLy7Dm8scoJKjwicLzmQ/640?wx_fmt=png&from=appmsg "")  
  
  
最终结果：因为服务器权限不足而导致失败,从报错可见，的确是尝试访问了对应的目录。  
  
  
![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnTzTK15lSh9yySicgYfpKWuszE3okfu6zrYa1a8l8wNl8VepzQ0FTvsVx5icjeTvBdwX9sduCE1CgKg/640?wx_fmt=png&from=appmsg "")  
  
  
  
换一个低权限路径尝试:当我将上述 base 路径改成 E:/Temp ，会出现以下内容(curl命令不变)。  
  
  
![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnTzTK15lSh9yySicgYfpKWusZZU4OgukZe5UiaUekGsOMSSPrrwrR22pgNxoicb5ibiaO9MVDRoLpU96sg/640?wx_fmt=png&from=appmsg "")  
  
  
  
成功！  
  
  
**总结：**  
因为不同操作系统的分隔符不同，攻击者在与不同于服务器操作系统的环境中构造tar包，并发送后能够绕过removeLeadingFileSeparator(...)从而导致最终Path生成的是攻击者控制的绝对路径，造成绝对路径遍历（不同于用../的相对路径遍历）。  
  
  
**（三）补充**  
  
![图片](https://mmbiz.qpic.cn/mmbiz_png/NGIAw2Z6vnLSsTccx7j0fJVU0OOoqKA8WFHRW8Evk0zcqAPJSmSRktqm69UXCNGtz8L1sz1g1Wg3sEYViamG90Q/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1&tp=webp "")  
  
  
通过实操可以发现，反过来操作[2]也是可以的。  
  
  
it is possible to create an archive on a Windows system, and when extracted on a MacOS or Linux system, write artifacts outside the intended destination during the extraction process. The reverse is also true for archives created on MacOS/Linux systems and extracted on Windows systems.  
  
![图片](https://mmbiz.qpic.cn/mmbiz_png/NGIAw2Z6vnLSsTccx7j0fJVU0OOoqKA8lvpAJHElQA6DiaJniaZb0daO3Kppz9ndV9Z2hHsjMuH61r2hu0jesGSg/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1&tp=webp "")  
  
**五、漏洞修复**  
  
  
请升级到最新版本，且补丁为  
[a  
pi] fix issue in Tar/Zip Utils that resulted in incorrect artifact … · 
deepjavalibrary/djl@7d197ba   
。  
  
  
![图片](https://mmbiz.qpic.cn/mmbiz_png/NGIAw2Z6vnLSsTccx7j0fJVU0OOoqKA8lvpAJHElQA6DiaJniaZb0daO3Kppz9ndV9Z2hHsjMuH61r2hu0jesGSg/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1&tp=webp "")  
  
**六、相关链接**  
  
  
[1]https://docs.djl.ai/master/index.html  
  
[2  
]Path traversal issue in Deep Java Library · Advisory · deepjavalibrary/djl,https://github.com/deepjavalibrary/djl/security/advisories/GHSA-jcrp-x7w3-ffmg.  
  
[3]huntr - The world’s first bug bounty platform for AI/ML,https://huntr.com/bounties/6199cf23-c9e0-4fcb-bb42-15dbf250e71c  
  
[4]CVE:Common Vulnerabilities and Exposures,https://www.cve.org/CVERecord?id=CVE-2025-0851.  
  
  
![图片](https://mmbiz.qpic.cn/mmbiz_png/NGIAw2Z6vnLSsTccx7j0fJVU0OOoqKA8KrXv9sZf93yt4huq2kARyZSgmdnic40GayohIYiaD2FAkkAqJehJSMtQ/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1&tp=webp "")  
  
山石网科是中国网络安全行业的技术创新领导厂商，由一批知名网络安全技术骨干于2007年创立，并以首批网络安全企业的身份，于2019年9月登陆科创板（股票简称：山石网科，股票代码：688030）。  
  
现阶段，山石网科掌握30项自主研发核心技术，申请540多项国内外专利。山石网科于2019年起，积极布局信创领域，致力于推动国内信息技术创新，并于2021年正式启动安全芯片战略。2023年进行自研ASIC安全芯片的技术研发，旨在通过自主创新，为用户提供更高效、更安全的网络安全保障。目前，山石网科已形成了具备“全息、量化、智能、协同”四大技术特点的涉及边界安全、云安全、数据安全、业务安全、内网安全、智能安全运营、安全服务、安全运维等八大类产品服务，50余个行业和场景的完整解决方案。  
  
![图片](https://mmbiz.qpic.cn/sz_mmbiz_gif/NGIAw2Z6vnLzibrp7C4HmazCNIQXMJIRxPibycdiaNQCI4PNojUk3eYCQDZs6c5zNMUkq7yFNeYQIxicAV33eHNdFA/640?wx_fmt=gif&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1&tp=webp "")  
  
  
