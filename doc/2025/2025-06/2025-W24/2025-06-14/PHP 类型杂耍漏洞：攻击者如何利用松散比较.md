> **原文链接**: https://mp.weixin.qq.com/s?__biz=MzI0MTUwMjQ5Nw==&mid=2247488984&idx=1&sn=90ec422c5c51bf0061ae125313358ac3

#  PHP 类型杂耍漏洞：攻击者如何利用松散比较  
红云谈安全  红云谈安全   2025-06-14 00:53  
  
**免责声明**  
  
由于传播、利用本公众号红云谈安全所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，公众号红云谈安全及作者不为**此**  
承担任何责任，一旦造成后果请自行承担！  
如有侵权烦请告知，我们会立即删除并致歉。谢谢！请在授权的站点测试，遵守网络安全法！  
**仅供**  
**学习使用，****如若非法他用，与平台和本文作者无关，需自行负责！**  
# 介绍  
  
PHP 是一种功能强大且广泛使用的服务器端脚本语言，为数百万个网站和应用程序提供支持。虽然其灵活性和易用性使其成为开发人员的最爱，但某些固有特性可能会导致严重的安全漏洞。类型玩弄就是其中之一，攻击者可以利用它来绕过身份验证、操纵数据并获得未经授权的访问。在本篇博文中，我们将探讨什么是 PHP 类型玩弄、它为何构成威胁、实际利用场景以及预防它的最佳实践。  
# 什么是 PHP 类型杂耍？  
  
PHP 是一种弱类型语言，这意味着它会根据上下文自动将变量在不同数据类型之间进行转换。这种隐式转换过程称为类型转换或类型强制转换。  
  
例如：  

```
if ( &#34;123&#34; == 123 ) { 
echo &#34;这是真的！&#34; ; 
}
```

  
这里，PHP 将字符串转换
```
123
```

为整数
```
123
```

，使得比较结果为
```
true
```

。  
  
虽然这种行为在某些情况下很方便，但在安全敏感操作中使用时也会导致意外和危险的漏洞。  
# PHP 中的松散比较与严格比较  
  
PHP 提供两种类型的比较运算符：  
  
**松散比较（== 和 !=）：**在比较之前将值转换为通用类型。  
  
例子：  

```
var_dump ( &#34;0e12345&#34; == &#34;0e67890&#34; ); // 输出：bool(true)
```

  
这里，两个值都被视为
```
0
```

科学计数法（
```
0e+12345
```

并且
```
0e+67890
```

都相等
```
0
```

）。  
  
严格比较（=== 和 !==）：比较值和数据类型。  
  
例子：  

```
var_dump ( &#34;123&#34; === 123 ); // 输出：bool(false)
```

  
由于一个是字符串，另一个是整数，因此比较失败。  
  
使用松散比较（
```
==
```

）会带来安全风险，因为攻击者可以操纵输入值来利用这些自动类型转换。  
# 为什么 PHP 类型杂耍很危险？  
## 1. 身份验证绕过  
  
考虑以下易受攻击的身份验证代码：  

```
$stored_hash = &#34;0e12345&#34; ; // 存储在数据库中的哈希值
$user_hash = $_POST [ 'password_hash' ]; // 用户输入
if ( $user_hash == $stored_hash ) { 
echo &#34;Access grant!&#34; ; 
}
```

## 开发：  
  
攻击者可以提交
```
0e67890
```

password_hash ，而 PHP 会将其视为
```
0
```

，因此比较结果为
```
true
```

。这会导致未经授权的访问。  
## 2. 魔法哈希  
  
某些哈希函数可以生成一些字符串，这些字符串在进行粗略比较时会得出真值。这些字符串被称为魔法哈希。  
  
例子：  

```
md5（“240610708”）= “0e462097431906509019562988736854” 
md5（“QLTHNDT”）= “0e830400451993494058024219903391”
```

  
这两个哈希值都以 0e 开头，PHP 会将其解释为
```
0
```

科学计数法。如果在身份验证检查中使用，攻击者可以利用此哈希值在不知道实际密码的情况下登录。  
## 3. JSON/API 输入操作  
  
如果应用程序使用 json_decode() 来处理用户输入，攻击者可以操纵数据类型来绕过安全检查。  
  
易受攻击的代码：  

```
$input = json_decode（$_POST [ 'data' ]，true）;
如果（$input [ 'is_admin' ] == true）{ 
grant_admin_access（）; 
}
```

## 开发：  
  
攻击者可以发送：  

```
{ “is_admin” : 1 }
```

  
或者  

```
{ “is_admin” ：“true” }
```

  
由于 PHP 将这些值松散地转换为 true，因此攻击者获得了管理员访问权限。  
# 现实世界的利用：密码重置漏洞  
  
考虑使用令牌来验证用户的密码重置功能：  

```
$stored_token = &#34;0e12345&#34; ; // 数据库中存储的令牌
$user_token = $_GET [ 'token' ]; // 用户提供的令牌
if ( $user_token == $stored_token ) { 
reset_password (); 
}
```

## 开发：  
  
攻击者可以提供
```
0e67890
```

作为令牌。PHP 会将这两个值都视为
```
0
```

，从而允许未经授权的密码重置。  
# 如何预防 PHP 类型杂耍漏洞  
## 1. 使用严格比较（=== 和 !==）  
  
始终使用严格的比较运算符来确保类型和值匹配：  

```
如果（$user_token === $stored_token）{ 
reset_password（）; 
}
```

## 2. 使用 hash_equals() 进行安全比较  
  
不要依赖 ==，而是使用 hash_equals() 来安全地比较加密哈希值：  

```
if ( hash_equals ( $stored_hash , $user_hash )) { 
echo &#34;访问已授予！&#34; ; 
}
```

  
这可以防止时序攻击并确保精确匹配。  
## 3. 验证并清理输入  
  
确保所有用户输入在处理之前都经过严格验证：  

```
if (! is_string ( $user_input )||! ctype_digit ( $user_input )) { 
die ( &#34;无效输入&#34; ); 
}
```

## 4. 使用强哈希算法  
  
避免使用 MD5 和 SHA1 等弱哈希函数，因为它们容易受到魔法哈希攻击。请改用 password_hash() 和 password_verify()：  

```
$hash = password_hash ( &#34;mypassword&#34; , PASSWORD_BCRYPT); 
if ( password_verify ( $_POST [ 'password' ], $hash )) { 
echo &#34;登录成功&#34; ; 
}
```

## 5.启用严格类型检查  
  
在 PHP 文件的开头使用严格类型来强制数据类型安全：  

```
声明（strict_types= 1）；
```

  
这可以防止意外的类型转换。  
# 结论  
  
PHP 类型杂耍是一把双刃剑：虽然它简化了开发，但如果处理不当，可能会带来严重的安全风险。通过了解类型杂耍的工作原理并遵循最佳安全实践，开发人员可以保护其应用程序免受身份验证绕过、魔法哈希和 API 操纵攻击。  
  
对于漏洞赏金猎人来说，PHP 类型杂耍提供了宝贵的机会来发现其他人可能忽略的关键漏洞。保持警惕，彻底测试，并始终遵循安全的编码实践。  
  
  
  
  
  
