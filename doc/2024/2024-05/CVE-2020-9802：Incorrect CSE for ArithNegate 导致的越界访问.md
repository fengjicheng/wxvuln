#  CVE-2020-9802：Incorrect CSE for ArithNegate 导致的越界访问   
XiaozaYa  看雪学苑   2024-05-08 18:02  
  
```
```  
  
  
  
最近尝试阅读DFG jit  
相关源码，但是无从下手，网上资料甚少并且代码量巨大，所以笔者对应JSC  
的学习路线还是从相关CVE  
中去学习一些有关JSC  
的基础知识，这里逐渐积累，等到合适的时候，再去尝试阅读源码，该漏洞比较老了，但是复现漏洞不是目的，重要的是学习一些知识。复现这个漏洞主要是学习下CSE  
优化这个知识点，其实挺简单的。CSE  
即公共子表达式消除，其主要的操作就是将多个相同的表达式替换成一个变量，这个变量存储着计算该表达式后所得到的值，考虑如下代码：  
  
  
```
```  
  
  
  
上述代码可能会被优化成如下代码：  
  
  
```
```  
  
  
  
这样就避免了b * c  
表达式的重复运算，但是并非所有情况下都可以进行CSE  
优化，考虑如下代码：  
  
  
```
```  
  
  
  
这里我们就不可以将其优化为如下代码：  
  
  
```
```  
  
  
  
理由很简单，f()  
存在side effect  
，即obj  
对象可能在f()  
中被修改，比如如下代码：  
  
  
```
```  
  
  
  
如果这里将其优化，则导致a = b = 1  
从而出现错误，那么JIT  
编译器是如果判断公共子表达式是否可以进行消除呢？对于JSC  
而言，其会在DFG  
阶段收集相关信息，然后在FTL  
阶段利用收集的信息判断是否进行CSE  
优化，收集信息阶段主要在DFGClobberize  
函数中进行，这个我们后面再看。  
  
  
  
```
```  
  
  
  
手动引入patch  
然后编译即可：  
  
  
```
```  
  
#   
  
  
```
```  
  
  
  
可以看到上述补丁主要打在了clobberize  
函数中，通过前面的铺垫，可以知道这里应该就是DFG  
收集相关信息时出现错误，从而导致在FTL  
阶段发生错误的优化，定位到源码：  
> 这里代码很长，所以只需要定位关键代码即可  
  
  
```
```  
  
  
  
这里可以看到patch  
代码仅仅给PureValue  
函数添加了一个参数node->arithMode()  
，这里根据p0  
的文章可以知道：  
> The def() of the PureValue here expresses that the computation does not rely on any context and thus that it will always yield the same result when given the same inputs. However, note that the PureValue is parameterized by the ArithMode of the operation, which specifies whether the operation should handle (e.g. by bailing out to the interpreter) integer overflows or not. The parameterization in this case prevents two ArithMul operations with different handling of integer overflows from being substituted for each other. An operation that handles overflows is also commonly referred to as a “checked” operation, and an “unchecked” operation is one that does not detect or handle overflows.  
  
  
  
加上node->arithMode()  
表示说具体不同整数溢出处理方式的操作不能替换，然后操作根据是否检查溢出分为checked operation  
和unchecked operation。  
所以这里的漏洞就比较明显了，def(PureValue(node));  
表示能否进行替换只与输入的值有关，对于ArithNegate  
而言，其是unchecked operation  
，当value = TYPE_MIN  
时会发生溢出，即-TYPE_MIN = TYPE_MIN  
；对于ArithAbs  
而言，其是checked operation  
，当value = TYPE_MIN  
时，其会进行符合扩展去处理溢出情况，所以abs(TYPE_MIN) = |TYPE_MIN|  
；而ArithNegate  
与ArithAbs  
操作是可以产生相同的效果的，比如-(-1) = abs(-1)  
，所以对于如下代码是可以进行优化的：  
  
  
```
```  
  
  
  
上面优化看似不存在问题，但是当发生溢出时就会出现问题，比如如下代码：  
  
  
```
```  
  
  
  
可以看到这里优化CSE  
优化导致b  
的值发生错误，其本来应该为|TYPE_MIN|  
，但是编译器却认为其为TYPE_MIN  
，其实这就是这个漏洞的全部原理了。poc  
如下：  
  
  
```
```  
  
  
  
可以看到这里输出的b = -2147483648 = -0x80000000  
，来简单看看字节码。  
  
  
首先看看f  
产生的字节码：  
  
  
```
```  
  
  
  
[11] negate  
表示的就是-n  
，[41] call  
表示的就是Math.abs(n)  
，来看下在DFG  
后的字节码。  
  
  
可以看到[11] negate  
被展开为如下IR  
：  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8FQicadOCiboLpxXIRw7OaqYTzUQ4NejYOSxULjKy2I0ibZ0Q0C6GsK15iajBXlD655Y0xnMShVmsf5gA/640?wx_fmt=png&from=appmsg "")  
  
[41] call  
被展开为如下IR  
：  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8FQicadOCiboLpxXIRw7OaqYTazpJrIsJicw4eLqvmp40OVvc0JshB28iamtibPkyic1EJok2Rz2rmuVwIw/640?wx_fmt=png&from=appmsg "")  
  
  
即：  
  
  
```
```  
  
  
  
可以看到ArithNegate  
是unchecked  
的，而ArithAbs  
是CheckOverflow  
的，即ArithNegate  
与ArithAbs  
具有不同的溢出处理机制。接下来看看FTL  
阶段：  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8FQicadOCiboLpxXIRw7OaqYTyhqRickCTXHiasubbzUaDsKdJdbRpblOibahls2AclA1qQmYIIicqa3png/640?wx_fmt=png&from=appmsg "")  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8FQicadOCiboLpxXIRw7OaqYT52dzGWrkyDYV1mZssmm95oXjs1yxeibu8mVp05HqpfEXa7aic8xLZNiaw/640?wx_fmt=png&from=appmsg "")  
  
  
即：  
  
  
```
```  
  
  
  
可以看到这里ArithAbs  
被优化掉了，即编译器认为ArithNegate  
与ArithAbs  
在操作数是负数时是等效的，但是上面说了这两个操作对于溢出的处理情况是不同的，所以这两个操作并不是完全等效的。  
  
  
  
```
```  
  
  
  
接下来就该考虑如何去进行利用了，总结一下上面漏洞的效果：  
  
  
◆一个运行时不一致的TYPE_MIN  
  
  
后面的利用有点类似于V8  
中消除CheckBounds  
节点，即利用编译器检查时与运行时不一致漏洞去消除边界检查，考虑如下代码：  
  
  
```
```  
  
  
  
可以看到这里【1】  
处首先保证了n < arr.length  
，【2】  
处为减二，所以n < arr.length-2 < arr.length  
，【3】  
处保证了n >= 0  
，所以编译器最后会推断arr[n]  
中的n  
的范围在[0, arr.length)  
之间，所以其肯定不会发生越界，所以其会进行消除边界检查优化。来看下trigger  
函数的字节码：  
  
  
```
```  
  
  
  
这里主要关注get_by_val  
字节码，来看看DFG  
阶段：  
  
  
```
```  
  
  
  
这里我们主要关注下GetButterfly  
和GetByVal  
：  
  
  
```
```  
  
  
  
从汇编代码可以看到在DFG  
阶段并没有消除数组的边界检查，其还是会检查n  
是否越界，所以我们再来看下FTL  
阶段：  
  
  
```
```  
  
  
  
这里的GetByVal  
节点与DFG  
阶段的似乎没啥不同，所以还是得看汇编代码，但是这里json  
似乎没有FTL  
阶段的汇编代码，所以只能动态调试了，这里调试可以知道：  
  
```
```  
  
  
  
rcx = butterfly; rax = n  
，所以这里是直接进行读取butterfly[n]  
，并没有对n  
进行检查，因为编译器推断此时n  
是在数组范围内的。那么回到原漏洞利用中，我们该如何利用漏洞去消除边界检查呢？其实关键就是**编译器推断时与实际运行时的值不相同**，考虑如下poc  
：  
  
  
```
```  
  
  
  
poc  
的原理我注释已经写的很清楚了，就不多说了，最后输出如下：  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8FQicadOCiboLpxXIRw7OaqYT1ev3vEhpkyyV5eNx9grrCgOLRibrickVuJiaibnj8BPArrxBmyibI1v0RdQ/640?wx_fmt=png&from=appmsg "")  
  
  
可以看到这里成功完成越界读，越界写简单修改下代码为arr[b] = val  
即可，poc  
的一些构造细节可以参考p0  
的文章，其poc  
写的更加好，解析的也很详细。有了越界地址读写后面其实就比较简单，我们可以利用该漏洞越界写修改相邻数组的butterfly  
的 “容量和长度”，这样就有了一个越界数组，后面就是构造addressOf/fakeObject  
原语，然后套模板就行了，就不多说了。  
  
  
exploit  
如下：  
  
  
```
```  
  
  
  
效果如下：  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8FQicadOCiboLpxXIRw7OaqYTj7RlGCLFRbD33AYIHlkK5lOWOqxhribbdexfZrm097wBCNQ6arF36yA/640?wx_fmt=png&from=appmsg "")  
#   
  
  
```
```  
  
  
  
通过复现该漏洞，笔者对CSE  
优化有了一个大致的了解，并且对一些优化的细节有了更加深刻的理解。然后比较重要的是学到了在JSC  
中如何消除边界检查从而完成越界读写。然后在参考文章中，作者写了他是如何发现这个漏洞的，这个漏洞并不是fuzz  
出来的，作者也说明了该类漏洞fuzz  
的困难性，而作者发现这个漏洞的原因是因为作者在审计代码时发现有的操作没有设置arithMode  
，而有的操作却设置了arithMode  
，所以作者就想为什么有的操作需要设置arithMode  
，而有的操作却不需要设置arithMode  
，于是作者就搜索相关没有设置arithMode  
的操作，从而发现了该漏洞。从作者发现该漏洞的历程中，也让我反思自己，自己在看代码时完全没有思考过为什么，其实还是自己不善于思考，这也许就是我与大佬的差距吧。  
  
# 参考  
  
https://googleprojectzero.blogspot.com/2020/09/jitsploitation-one.html  
  
  
  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8FQicadOCiboLpxXIRw7OaqYTicpRhTlicDQQt6dwQ6XRXT7xs1vibtGFpibgOCrupPymNyePqunL6C2EGw/640?wx_fmt=png&from=appmsg "")  
  
  
**看雪ID：XiaozaYa**  
  
https://bbs.kanxue.com/user-home-965217.htm  
  
*本文为看雪论坛优秀文章，由 XiaozaYa 原创，转载请注明来自看雪社区  
  
  
[](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458553456&idx=3&sn=11b55ee464d5aecd37fb4c5bc4dab5da&chksm=b18dbcfa86fa35ecef07864a534f85924153d8b32a403a57e2f3f2d5c266ce199c02bbcb9434&scene=21#wechat_redirect)  
  
  
  
**#****往期推荐**  
  
1、[通过BLECTF入门BLE](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458553587&idx=1&sn=555f3300fdfb937c866049ec95101e07&chksm=b18dbc7986fa356f385dbffe62de254e6d722f876becce0a78ebe8c2b742e83a71fd87bea561&scene=21#wechat_redirect)  
  
  
2、[InfinityHook 可兼容最新版windows](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458553456&idx=1&sn=2df223026199d77ea1ee2672cd2792a4&chksm=b18dbcfa86fa35ece674c4810d4596eafd31fb2fee0e692de35fd9375dff614fccb9583c2704&scene=21#wechat_redirect)  
  
  
3、[CVE-2023-4427：ReduceJSLoadPropertyWithEnumeratedKey 中的越界访问](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458553432&idx=1&sn=93377c71147ef00b8e58571093d5ab55&chksm=b18dbcd286fa35c424bcf128759e907304820fb4289f407f6ba5ecd0b48897ce31ddb7623caa&scene=21#wechat_redirect)  
  
  
4、[Windows 主机入侵检测与防御内核技术深入解析](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458553431&idx=1&sn=c2d1e01e4c6720d78bc1574c7bf31a57&chksm=b18dbcdd86fa35cbcc56961d6fb31e826c79008814e3861f332d23b87c85910e7f2cf152f7d6&scene=21#wechat_redirect)  
  
  
5、[Linux Kprobe原理探究](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458553430&idx=1&sn=2ad5d4bd06eff9aa2e8ac1e460c7db06&chksm=b18dbcdc86fa35cafa6749f7adb007e143c72aac763385272e45151146eef7788fd8012ceb8a&scene=21#wechat_redirect)  
  
  
  
![](https://mmbiz.qpic.cn/mmbiz_jpg/Uia4617poZXP96fGaMPXib13V1bJ52yHq9ycD9Zv3WhiaRb2rKV6wghrNa4VyFR2wibBVNfZt3M5IuUiauQGHvxhQrA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1 "")  
  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_gif/1UG7KPNHN8GJubmq65v9uBFmEJuoJD78321RiaLpp3FAylJv0nbibloCFmXdVe4wvW4ibgnCc6srNI8sGBkX14MpQ/640?wx_fmt=gif&from=appmsg "")  
  
**球分享**  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_gif/1UG7KPNHN8GJubmq65v9uBFmEJuoJD78321RiaLpp3FAylJv0nbibloCFmXdVe4wvW4ibgnCc6srNI8sGBkX14MpQ/640?wx_fmt=gif&from=appmsg "")  
  
**球点赞**  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_gif/1UG7KPNHN8GJubmq65v9uBFmEJuoJD78321RiaLpp3FAylJv0nbibloCFmXdVe4wvW4ibgnCc6srNI8sGBkX14MpQ/640?wx_fmt=gif&from=appmsg "")  
  
**球在看**  
  
  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_gif/1UG7KPNHN8GJubmq65v9uBFmEJuoJD78txPhfvI9WpuGSCawCN8NJCgzD16Y0IwdUkaI33Qr3DpwRRuvibgRQOg/640?wx_fmt=gif&from=appmsg "")  
  
点击阅读原文查看更多  
  
