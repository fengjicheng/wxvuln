#  CVE-2024-22263：Spring Cloud Dataflow中路径遍历导致的任意文件写入漏洞   
 Ots安全   2024-08-24 16:17  
  
![](https://mmbiz.qpic.cn/mmbiz_gif/bL2iaicTYdZn7gtxSFZlfuCW6AdQib8Q1onbR0U2h9icP1eRO6wH0AcyJmqZ7USD0uOYncCYIH7ZEE8IicAOPxyb9IA/640?wx_fmt=gif "")  
  
网址  
  
https://blog.securelayer7.net/spring-cloud-data-flow-exploit/  
  
目标  
  
Spring Cloud Dataflow < 2.11.3  
  
**解释**  
  
Spring Cloud Dataflow 中发现了任意文件写入漏洞并披露了详细信息，Spring Cloud Dataflow 是一个基于微服务的工具包，用于在 Cloud Foundry/Kubernetes 上构建流和数据处理管道。  
  
该漏洞存在于**  
PackageService.java模块 的一个方法中，该模块是一个处理包上传请求的 Skipper 服务器组件 。  
> Skipper 是一个可以跨多个云平台管理 Spring Boot 应用程序生命周期的工具。  
  
  
  
/api/package/upload您可以通过端点的 Skipper 服务器 API 发送针对任意路径的上传请求。  
```
@Transactional

public PackageMetadata upload(UploadRequest uploadRequest) {

    validateUploadRequest(uploadRequest);
```  
  
upload该方法通过调用来验证攻击者的请求  
UploadRequest。  
validateUploadRequest  
```
private void validateUploadRequest(UploadRequest uploadRequest) {
    Assert.notNull(uploadRequest.getRepoName(), "Repo name can not be null");
    Assert.notNull(uploadRequest.getName(), "Name of package can not be null");
    Assert.notNull(uploadRequest.getVersion(), "Version can not be null");
    // Other checks...
}
```  
  
validateUploadRequest   
该方法执行空检查以确定包文件是否为空。  
```
Path packageFile = Paths.get(packageDir.getPath() + File.separator + uploadRequest.getName() + "-" + uploadRequest.getVersion() + "." + uploadRequest.getExtension());
```  
  
经过验证后  
upload，该方法使用攻击者的输入  
packgeFile构建路径并在该路径中构建包文件。  
  
在上述过程中，存在以下验证缺陷。  
1. validateUploadRequest(uploadReqeust)在验证过程中，  
uploadRequest无法验证实际的文件路径，因为验证是在文件系统中创建实际路径之前进行的。  
  
1. validateUploadRequest该方法除了空包检查之外，没有路径遍历检查等验证逻辑。  
  
1. Path packageFile配置无需验证用户输入  
uploadRequest即可完成。  
  
攻击者可以通过发送名称字段中包含路径遍历负载的 uploadRequest 请求将文件写入任意路径。  
```
uploadRequest = {
    "repoName": repoName,
    "name": "../../poc",
    "version": version,
    "extension": "zip",
    "packageFileAsBytes": packageFileAsBytes
}
```  
  
该漏洞已修复如下：  
  
1.  
validateUploadRequest(uploadReqeust)  
在调用之前，创建一个在上传过程中使用的文件路径。  
```
@Transactional

public PackageMetadata upload(UploadRequest uploadRequest) {

    Path packageDirPath = TempFileUtils.createTempDirectory("skipperUpload");

    validateUploadRequest(packageDirPath, uploadRequest);
```  
  
2.validateUploadRequest 方法检查实际文件路径并 过滤路径遍历负载，例如检查是否以 开头，  
canonicalDestinationFilepath这是目录的标准路径。canonicalDestinationDirPath  
../../  
```
private void validateUploadRequest(Path packageDirPath, UploadRequest uploadRequest) throws IOException {
    // Existing null checks...

    File destinationFile = new File(packageDirPath.toFile(), uploadRequest.getName().trim());
    String canonicalDestinationDirPath = packageDirPath.toFile().getCanonicalPath();
    String canonicalDestinationFile = destinationFile.getCanonicalPath();

    if (!canonicalDestinationFile.startsWith(canonicalDestinationDirPath + File.separator)) {
        throw new SkipperException("Entry is outside of the target dir: " + uploadRequest.getName());
    }
}
```  
  
3.通过使用trim()清理请求路径来防止其他文件路径操作。  
```
String fullName = uploadRequest.getName().trim() + "-" + uploadRequest.getVersion().trim() + "." + uploadRequest.getExtension().trim();
Path packageFile = Paths.get(packageDir.getPath() + File.separator + fullName);
```  
  
  
  
  
  
感谢您抽出  
  
![](https://mmbiz.qpic.cn/mmbiz_gif/Ljib4So7yuWgdSBqOibtgiaYWjL4pkRXwycNnFvFYVgXoExRy0gqCkqvrAghf8KPXnwQaYq77HMsjcVka7kPcBDQw/640?wx_fmt=gif "")  
  
.  
  
![](https://mmbiz.qpic.cn/mmbiz_gif/Ljib4So7yuWgdSBqOibtgiaYWjL4pkRXwycd5KMTutPwNWA97H5MPISWXLTXp0ibK5LXCBAXX388gY0ibXhWOxoEKBA/640?wx_fmt=gif "")  
  
.  
  
![](https://mmbiz.qpic.cn/mmbiz_gif/Ljib4So7yuWgdSBqOibtgiaYWjL4pkRXwycU99fZEhvngeeAhFOvhTibttSplYbBpeeLZGgZt41El4icmrBibojkvLNw/640?wx_fmt=gif "")  
  
来阅读本文  
  
![](https://mmbiz.qpic.cn/mmbiz_gif/Ljib4So7yuWge7Mibiad1tV0iaF8zSD5gzicbxDmfZCEL7vuOevN97CwUoUM5MLeKWibWlibSMwbpJ28lVg1yj1rQflyQ/640?wx_fmt=gif "")  
  
**点它，分享点赞在看都在这里**  
  
