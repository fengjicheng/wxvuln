#  第八课-系统学习代码审计：XXE和XSS(VUE中可能存在的漏洞)翻车讲解   
原创 开发小鸡娃  安全随心录   2024-07-26 21:52  
  
视频地址见：上几篇文章：  
  
主要内容：  
  
    1、常见存在XXE漏洞的写法以及修复方法  
  
    2、XSS常见的位置：1、前后不分离2、前后端分离下，vue中可能存在XSS的地方（翻车 :( ）。  
  
进群：后台回复进群即可。  
XXE漏洞概述    XXE漏洞，全称XML外部实体注入漏洞，是一种常见的针对解析XML输入的应用程序的安全漏洞。当应用程序在解析XML数据时，如果没有正确验证或限制实体引用，攻击者就可以通过构造恶意的XML输入，将外部实体引用进来，从而执行恶意操作。XML常见接口XMLReader    XMLReader是SAX（Simple API for XML）的一部分，用于解析XML文档。    XMLReader接口由SAX2定义，它允许应用程序逐行解析XML文档。通常通过SAXParserFactory来创建XMLReader实例public static void XMLReaderTest() throws SAXException, IOException, ParserConfigurationException {        // 创建XMLReader实例        XMLReader xmlReader = XMLReaderFactory.createXMLReader();        // 创建处理器        DefaultHandler handler = new DefaultHandler() {            @Override            public void startElement(String uri, String localName, String qName, Attributes attributes) {                // 处理开始元素                System.out.println("Start Element: " + qName);            }            @Override            public void endElement(String uri, String localName, String qName) {                // 处理结束元素                System.out.println("End Element: " + qName);            }            @Override            public void characters(char[] ch, int start, int length) {                // 处理元素内容                System.out.println("Characters: " + new String(ch, start, length));            }        };        // 将处理器设置为XMLReader的内容处理器        xmlReader.setContentHandler(handler);        // 解析XML文档        File file = new File("E:\\code\\Java代码审计系统学习\\CodeReviewStudy\\day9-XXE\\src\\main\\java\\com\\llu\\baseTest\\example.xml");        InputSource inputSource = new InputSource(file.toURI().toURL().toString());        xmlReader.parse(inputSource);    }    public static void XmLReaderFixTest() throws Exception {        // 配置SAXParserFactory以防止XXE攻击        SAXParserFactory factory = SAXParserFactory.newInstance();        // 创建XMLReader实例 ，错误的修复方式， 需要先设置setFeature ，在获取 xmlReader//        XMLReader xmlReader = factory.newSAXParser().getXMLReader();        factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);        factory.setFeature("http://xml.org/sax/features/external-general-entities", false);        factory.setFeature("http://xml.org/sax/features/external-parameter-entities", false);        factory.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);        // 正确的修复方式        XMLReader xmlReader = factory.newSAXParser().getXMLReader();        // 创建处理器        DefaultHandler handler = new DefaultHandler() {            @Override            public void startElement(String uri, String localName, String qName, Attributes attributes) {                System.out.println("Start Element: " + qName);            }            @Override            public void endElement(String uri, String localName, String qName) {                System.out.println("End Element: " + qName);            }            @Override            public void characters(char[] ch, int start, int length) {                System.out.println("Characters: " + new String(ch, start, length));            }        };        // 将处理器设置为XMLReader的内容处理器        xmlReader.setContentHandler(handler);        // 解析XML文档        File file = new File("E:\\code\\Java代码审计系统学习\\CodeReviewStudy\\day9-XXE\\src\\main\\java\\com\\llu\\baseTest\\example.xml");        InputSource inputSource = new InputSource(file.toURI().toURL().toString());        xmlReader.parse(inputSource);    }DocumentBuilderFactory 和 DocumentBuilder    DocumentBuilderFactory类在javax.xml.parsers包中。它是Java的标准库之一，用于创建用于解析XML文档的DocumentBuilder实例。许多Java项目和框架使用DocumentBuilderFactory来解析XML数据。以下是一些常见的使用场景和项目：    Spring Framework    Apache Tomcatpublic static void vul() throws Exception {       /**     * 创建一个 DocumentBuilderFactory 实例来解析 XML 文档     */    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();    /**     * 使用 DocumentBuilderFactory 创建一个 DocumentBuilder 实例     */    DocumentBuilder builder = factory.newDocumentBuilder();    /**     * 解析 example.xml 文件并获取一个 Document 对象     */    Document document = builder.parse(new File("E:\\code\\Java代码审计系统学习\\CodeReviewStudy\\day9-XXE\\src\\main\\java\\com\\llu\\baseTest\\example.xml"));    /**     * 输出文档根元素的内容     * 这里处理文档     */    System.out.println(document.getDocumentElement().getTextContent());    }    /**     * DocumentBuilder builder = dbf.newDocumentBuilder();这行代码需要在dbf.setFeature()之后才能够生效；     */    public static void fix() throws Exception {        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();        // 错误的修改方式 DocumentBuilder builder = dbf.newDocumentBuilder();这行代码需要在dbf.setFeature()之后才能够生效；        // DocumentBuilder builder = dbf.newDocumentBuilder();        String FEATURE = null;        FEATURE = "http://javax.xml.XMLConstants/feature/secure-processing";        dbf.setFeature(FEATURE, true);        FEATURE = "http://apache.org/xml/features/disallow-doctype-decl";        dbf.setFeature(FEATURE, true);        FEATURE = "http://xml.org/sax/features/external-parameter-entities";        dbf.setFeature(FEATURE, false);        FEATURE = "http://xml.org/sax/features/external-general-entities";        dbf.setFeature(FEATURE, false);        FEATURE = "http://apache.org/xml/features/nonvalidating/load-external-dtd";        dbf.setFeature(FEATURE, false);        dbf.setXIncludeAware(false);        dbf.setExpandEntityReferences(false);        // 正确的修复方式        DocumentBuilder builder = dbf.newDocumentBuilder();        /**         * 解析 example.xml 文件并获取一个 Document 对象         */        Document document = builder.parse(new File("E:\\code\\Java代码审计系统学习\\CodeReviewStudy\\day9-XXE\\src\\main\\java\\com\\llu\\baseTest\\example.xml"));        /**         * 输出文档根元素的内容         * 这里处理文档         */        System.out.println(document.getDocumentElement().getTextContent());    }XSS漏洞简介略XSS漏洞在可能出现的位置前后端不分离<%=${<c:out<c:if<c:forModelAndViewModelMapModelrequest.getParameterrequest.setAttributeresponse.getWriter().print()response.getWriter().writer()前后端分离    如果使用VUE或react，基本无漏洞，因为vue和react在渲染的时候会自动对html最实体编码。可能出现的地方是直接回显到前端，如果在filter中。直接返回数据。response.getWriter().print()response.getWriter().writer()修复方式：// 设置编码        response.setCharacterEncoding("UTF-8");        response.setContentType("text/html;charset=UTF-8");        // 对用户输入进行HTML转义String safeUsername= StringEscapeUtils.escapeHtml4(username);        response.getWriter().write("用户名错误 : " + safeUsername);// 上面的修复方式需要引入依赖<dependency>    <groupId>org.apache.commons</groupId>    <artifactId>commons-text</artifactId>    <version>1.9</version></dependency>// 如果不引入依赖可以做如下替换userName = userName.replaceAll("<", "&lt;").replaceAll(">", "&gt;");vue中可能存在的XSSv-html    v-html 是一个指令，用于动态地将 HTML 内容插入到元素中。与 {{ }} 绑定文本不同，v-html 可以解析并插入 HTML 内容，这使得你可以将 HTML 代码直接渲染到 DOM 中。<div v-html="msg"></div>修复方式--DOMPurify    DOMPurify 是一个非常强大的库，用于清理和消毒 HTML 内容。它的主要目标是防止 XSS（跨站脚本攻击）和其他基于 HTML 的注入攻击。DOMPurify.sanitize 会移除或清理潜在的恶意代码，包括嵌入的 JavaScript 代码。具体地说，DOMPurify 会过滤掉不安全的元素和属性，而不是将其转换为实体编码。this.msg =  DOMPurify.sanitize(this.msg);动态插入属性// img利用条件比较苛刻<img :src="img" /><a :href="click">Click me</a>内联事件处理器<!-- 可能引发 XSS --><button @click="userInput">Click me</button>XSS绕过见TOPN-XSS，常规的就不说了，主要写下DOMPurify的绕过payload// DOMPurify < V2.0.0 <svg></p><style><a id="</style><img src=1 onerror=alert(1)>">// DOMPurify <=  2.0.17<form>    <math><mtext></form><form>    <mglyph>        <style></math><img src onerror=alert(1)>XSS防御见上文参考文章：安全 | Vue.js (vuejs.org)  
  
  
