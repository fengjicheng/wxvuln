#  SolarWinds Security Event Manager AMF 反序列化 RCE (CVE-2024-0692)   
 船山信安   2024-03-06 00:00  
  
## 前言  
  
前几天刷推看到 ZDI 发了 SolarWinds Security Event Manager AMF 反序列化 RCE 的通告, 于是准备简单分析一下  
  
https://www.zerodayinitiative.com/advisories/ZDI-24-215/  
  
https://www.solarwinds.com/security-event-manager  
  
首先说一下拿源码的流程  
  
这个产品在官网就能下载到安装包, 里面是 ova 格式的 Linux 虚拟机, 需要手动导入 VMware  
  
然后翻阅官方文档可以知道, 产品本身提供了 SSH 的功能, 但是 Shell 是一个受限的 cmcshell  
  
![](https://mmbiz.qpic.cn/mmbiz_png/7nIrJAgaibicNp3ricpkY8BOGRSISbKiaykq3NWiaQTS5g3f9TsptYwCiaUD65jzH3ZSB1w9k55bGJmsULohpzdosABg/640?wx_fmt=png&from=appmsg "")  
  
appliance 菜单内可以执行 top 命令, 观察发现这是一个用 Java 编写的应用  
  
![](https://mmbiz.qpic.cn/mmbiz_png/7nIrJAgaibicNp3ricpkY8BOGRSISbKiaykqYeiaHsoLs9CJhd7zGgDiaOKbmNITia5kJvAZlS9wkQPF8iaVI2o6h6qHXA/640?wx_fmt=png&from=appmsg "")  
  
cmcshell 本身没发现什么可以命令注入的地方, 所以只能通过虚拟机的 vmdk 文件读取磁盘内容拿到源码  
  
这里我用的是 DiskGenius, 经过查找发现源码位于 lem 分区的 contego 目录  
  
![](https://mmbiz.qpic.cn/mmbiz_png/7nIrJAgaibicNp3ricpkY8BOGRSISbKiaykqLb0XeojEtlLjzIqVvknIeiam54RyS8YW1MBGnswho9V2MMVicQmsAKZQ/640?wx_fmt=png&from=appmsg "")  
  
最后全部复制出来就行  
  
同时得注意 Java 版本为 17, 并且没有 javac (后面会提到)  
  
![](https://mmbiz.qpic.cn/mmbiz_png/7nIrJAgaibicNp3ricpkY8BOGRSISbKiaykqshg1stcFljOADAfVHQxnmhufrKHrfOSjvOSlQ6pjnM63JianDNXu98Q/640?wx_fmt=png&from=appmsg "")  
## AMF 反序列化  
  
AMF (Action Message Format) 反序列化基础知识  
  
https://codewhitesec.blogspot.com/2017/04/amf.html  
  
https://wouter.coekaerts.be/2011/amf-arbitrary-code-execution  
  
https://www.mi1k7ea.com/2019/12/07/Java-AMF3反序列化漏洞/  
  
https://blog.csdn.net/caiqiiqi/article/details/110629969  
  
简单来说就是一种基于 setter/getter 的二进制序列化协议, 其在反序列化的过程中会调用指定类的公共无参构造方法, 然后通过 setter 恢复相关字段  
  
另外在部分文章中会提到 AMF 只能序列化/反序列化实现 Serializable 接口的类, 但根据我的实际测试发现也可以序列化/反序列化非 Serializable 的类  
  
SolarWinds Security Event Manager 使用了 Apache Flex BlazeDS, 版本为 4.7.3  
  
![](https://mmbiz.qpic.cn/mmbiz_png/7nIrJAgaibicNp3ricpkY8BOGRSISbKiaykqzIAuxmer2xZX10sD7EKrcL2vgRedxhpTfick5wrrbJ4Fu02cib6V55Ow/640?wx_fmt=png&from=appmsg "")  
  
4.7.3 版本中官方默认禁用 AMF 反序列化, 并且引入了 ClassDeserializationValidator 来控制能够被反序列化的类  
  
https://github.com/apache/flex-blazeds/blob/develop/RELEASE_NOTES  
```
```  
  
相关配置位于 services-config.xml  
  
对于 SolarWinds Security Event Manager, 这个文件位于 contego/run/tomcat/webapps/ROOT/WEB-INF/flex/services-config.xml  
```
```  
  
根据上述 XML 配置可以知道  
1. 处理 AMF 数据的两个 Endpoint (另外还有两个 8080 端口的但是无法访问)  
  
1. https://{server.name}:8443/services/messagebroker/amf, 对应 flex.messaging.endpoints.SecureAMFEndpoint  
  
1. https://{server.name}:8443/services/messagebroker/streamingamf, 对应 com.solarwinds.lem.flex.blazeds.ManagedSecureStreamingAmfEndpoint  
  
1. validator 标签的 allow-classes 属性被设置成 .*, 即允许任意类被反序列化  
  
以 ManagedSecureStreamingAmfEndpoint 为例  
  
其父类 flex.messaging.endpoints.StreamingAMFEndpoint 会在请求时创建 FilterChain (责任链模式), 其中包含 SerializationFilter  
  
![](https://mmbiz.qpic.cn/mmbiz_png/7nIrJAgaibicNp3ricpkY8BOGRSISbKiaykqph8DEAGIibNGRPde107HmEuoXPoRosIdXZibuKTncyPw1wXiaJ3HxvUyA/640?wx_fmt=png&from=appmsg "")  
  
flex.messaging.endpoints.amf.SerializationFilter#invoke  
  
代码比较长, 仅截取部分内容  
  
![](https://mmbiz.qpic.cn/mmbiz_png/7nIrJAgaibicNp3ricpkY8BOGRSISbKiaykqKka8ib9WDib3Lsogh3X5o4z7Zl8XP5lNlNz2zdjuGDz59hKe5nYCDtrQ/640?wx_fmt=png&from=appmsg "")  
  
![](https://mmbiz.qpic.cn/mmbiz_png/7nIrJAgaibicNp3ricpkY8BOGRSISbKiaykqIKzKL8v1GAs6pPPibCpArSfpra96GvzuK4WoPoNgBgg0FPI3nLM9KMA/640?wx_fmt=png&from=appmsg "")  
  
这是一个非常明显的反序列化入口点, 没有任何鉴权措施, 直接 POST 数据并设置 Content-Type 为 application/amf 就能触发反序列化  
  
![](https://mmbiz.qpic.cn/mmbiz_png/7nIrJAgaibicNp3ricpkY8BOGRSISbKiaykq0upajCeMQ5aS3BKOxO0caW7uBmRhlgutLngbwjwFTGd6MjddfXnu3w/640?wx_fmt=png&from=appmsg "")  
  
难点在于后续 Gadget 的构造  
## HikariCP JNDI 注入  
  
jar 依赖  
```
```  
  
目标环境为 Java 17, 不存在 TemplatesImpl, 并且 JdbcRowSetImpl 会因为 Java 模块化的原因导致无法访问  
  
虽然存在 commons-beanutils 和 commons-collections4, 但是 AMF 反序列化的流程是调用公共无参构造函数 + setter 赋值, 入口点并不是 readObject, 也无法使用  
  
高版本 JDK 反序列化的利用思路大致都是通过 JDBC 攻击实现 RCE, 因此可以寻找一些直接能够发起 JDBC 连接的 gadget, 或者先获取 JNDI 注入, 然后通过 JDNI 发起 JDBC 连接  
  
注意到环境存在 HikariCP 依赖, 容易得到 com.zaxxer.hikari.HikariConfig 这个类  
  
![](https://mmbiz.qpic.cn/mmbiz_png/7nIrJAgaibicNp3ricpkY8BOGRSISbKiaykq1PsgEcGtByBtWxIjK7iaKC1cdjDPKVTRQJdGrPBGtN1pfibnxZ9DvicGw/640?wx_fmt=png&from=appmsg "")  
  
经典的 JNDI 注入  
```
```  
  
将生成的 payload.amf 发送给目标服务器, 即可收到 JNDI 请求  
```
```  
## 受限制的 JDBC H2 RCE  
### 利用思路  
  
后续原本想通过 JNDI 注入打 Java 原生反序列化, 但是没找到合适的 gadget  
  
commons-collections4 为最新的 4.4 版本, 这个版本使得包括 InvokerTransformer 在内的一系列 Transformer 都不再实现 Serializable 接口, 无法被反序列化  
  
commons-beanutils 虽然可以利用, 但没有了 TemplatesImpl, 一时半会没找到其它的 getter gadget  
  
于是转向 JDBC, 观察到环境存在 H2 依赖, 因此可以尝试 H2 RCE  
  
首先需要将 JNDI 转换成 JDBC 攻击, 参考: https://tttang.com/archive/1405/  
  
同理, 在 HikariCP 中也存在类似的实现了 ObjectFactory 接口的类, 即 com.zaxxer.hikari.HikariJNDIFactory, 其 getObjectInstance 方法会发起 JDBC 连接  
  
![](https://mmbiz.qpic.cn/mmbiz_png/7nIrJAgaibicNp3ricpkY8BOGRSISbKiaykquYThNmzGqWntfqkY49g30icF7YkB7OYQH8qdK3llb3wmD5F7ibKoW9xg/640?wx_fmt=png&from=appmsg "")  
  
https://github.com/X1r0z/JNDIMap/blob/main/src/main/java/map/jndi/controller/database/HikariCPController.java#L21  
```
```  
  
然后是 H2 数据库 RCE, 有三种方法: CREATE ALIAS + Java/Groovy, CREATE TRIGGER + JavaScript  
  
https://paper.seebug.org/1832/  
  
不过在目标环境下都不能利用成功  
  
CREATE TRIGGER + JavaScript 会提示语法错误  
  
这是因为 Java 自带的 Nashorn JavaScript 引擎已经在 Java 15 往后被删除, 而目标环境使用的是 Java 17  
  
![](https://mmbiz.qpic.cn/mmbiz_png/7nIrJAgaibicNp3ricpkY8BOGRSISbKiaykqopqpRIG9zcSKibfl11f0cRDLLgYaTW8597PQgvibiaacpLT7xcwZMKNTg/640?wx_fmt=png&from=appmsg "")  
  
环境不存在 Groovy 依赖, 因此 CREATE ALIAS + Groovy 也会报错  
  
![](https://mmbiz.qpic.cn/mmbiz_png/7nIrJAgaibicNp3ricpkY8BOGRSISbKiaykqFCKjm5FoYuQFq5Os4DDiabvsZWicxLmPuIv0NY05vBBnqw0A2hGjCXpQ/640?wx_fmt=png&from=appmsg "")  
  
CREATE ALIAS + Java 同样报错, 这个就比较有意思了  
  
在开头提到过, 虚拟机内置的 Java 17 没有 javac 命令, 因此就不能通过 CREATE ALIAS 语句动态编译 Java 源代码  
  
![](https://mmbiz.qpic.cn/mmbiz_png/7nIrJAgaibicNp3ricpkY8BOGRSISbKiaykqItjQ7cYQ3ugs4RhUJFJwgib8RG7xMh0elCoOHZOxMK5t5dno36upkLA/640?wx_fmt=png&from=appmsg "")  
  
但实际上翻阅文档可以知道, H2 的 CREATE ALIAS 仍然可以调用位于 classpath 内的某个公共类的公共静态方法, 这点与 Oracle 类似  
  
https://h2database.com/html/features.html  
  
https://h2database.com/html/datatypes.html  
  
![](https://mmbiz.qpic.cn/mmbiz_png/7nIrJAgaibicNp3ricpkY8BOGRSISbKiaykqw78047LNe8gawW6waTzL9l5kgs9icgwNHL7E55W4xSoCaQ2fnKSH34A/640?wx_fmt=png&from=appmsg "")  
  
直接给出我的两种利用思路:  
  
写文件 + System.load  
1. 利用 File.createTempFile 创建临时文件  
  
1. 利用 commons-io 的 FileUtils 分块写文件  
  
1. 利用 commons-beanutils 的 MethodUtils 反射调用实例/静态方法  
  
1. 利用 System.load 加载动态链接库  
  
ClassPathXmlApplicationContext  
1. 利用 commons-beanutils 的 ConstructorUtils 实例化 ClassPathXmlApplicationContext  
  
1. XML 内调用 ProcessBuilder.start 执行命令  
  
### File Write + System.load  
  
payload (Groovy)  
```
```  
  
这里有几个注意点  
  
首先因为自 Java 9 引入的模块化机制, 不能直接使用 com.sun.org.apache.xml.internal.security.utils.JavaUtils.writeBytesToFilename 写文件, 因此需要找到一个来自第三方依赖的可以写文件的静态方法  
  
org.apache.commons.io.FileUtils#writeByteArrayToFile(java.io.File, byte[], boolean)  
```
```  
  
但是这个方法需要一个 File 对象, 那么就得接着找能够返回 File 对象的静态方法  
  
java.io.File#createTempFile(java.lang.String, java.lang.String, java.io.File)  
```
```  
  
然后 CREATE ALIAS 本身只能调用静态方法, 限制太多, 需要找到一个能够调用实例方法的静态方法 (用于后续调用 getAbsolutePath 以获取 File 对象的文件路径)  
  
org.apache.commons.beanutils.MethodUtils#invokeMethod(java.lang.Object, java.lang.String, java.lang.Object)  
  
org.apache.commons.beanutils.MethodUtils#invokeStaticMethod(java.lang.Class<?>, java.lang.String, java.lang.Object)  
```
```  
  
到这里肯定会有一个问题, 既然能够调用实例方法, 那么为什么不直接 java.lang.Runtime.getRuntime().exec(cmd) ?  
  
众所周知, 如果某个数据库支持调用外部方法, 那么就一定存在数据库类型与外部类型的映射  
  
在 H2 中, Java 的 java.lang.Object 类型对应数据库的 JAVA_OBJECT 类型  
  
![](https://mmbiz.qpic.cn/mmbiz_png/7nIrJAgaibicNp3ricpkY8BOGRSISbKiaykqelQ10jLgiceAvXTWm41ZNDCM96XQPsrahIklXOH8KSh9rsbhUJQrh6A/640?wx_fmt=png&from=appmsg "")  
  
JAVA_OBJECT 对应的 Java 对象必须是可序列化的 (Serializable)  
  
假如要执行 java.lang.Runtime.getRuntime().exec(cmd), SQL 语句如下  
```
```  
  
上述过程中 JVM 返回的 Class 对象和 Runtime 对象会被序列化保存在 H2 数据库的 clazz 和 runtime 变量内 (类型为 JAVA_OBJECT)  
  
而 java.lang.Runtime 没有实现 Serializable 接口, 因此 SQL 语句会报错, 即需要保证过程中使用的所有变量都得是可序列化的  
  
至于为什么还要专门找一个反射调用静态方法的 invokeStaticMethod, 这是因为上面通过 invokeMethod 调用 getAbsolutePath 返回的临时文件路径的类型为 java.lang.Object (实际上为 java.lang.String)  
  
但是 H2 不支持 JAVA_OBJECT 与 VARCHAR (CHARACTER VARYING) 之间的类型转换, 也就无法将路径作为参数传入 java.lang.System.load(java.lang.String)  
  
https://github.com/h2database/h2database/issues/3389  
  
因此需要找到一个参数类型为 java.lang.Object 的静态方法 (invokeStaticMethod), 然后通过这个方法间接调用 System.load, 进而加载动态链接库实现 RCE  
  
最后要注意编译出来的 .so 比较大, 转成 Hex 后字符串的长度过长, 直接写会报错, 需要分块写入  
  
利用流程:  
  
首先编写 exp.c  
```
```  
  
编译  
```
```  
  
根据之前的代码生成 payload.amf  
  
然后将 Groovy payload 保存, 运行 JNDIMap  
```
```  
  
curl 发送 amf payload  
```
```  
  
![](https://mmbiz.qpic.cn/mmbiz_png/7nIrJAgaibicNp3ricpkY8BOGRSISbKiaykq3JNf6wFztc0GU6rPhhtgvI2wL4v6kzA6zvP1vzPE82hAGWCEo1LTKQ/640?wx_fmt=png&from=appmsg "")  
### ClassPathXmlApplicationContext  
  
payload (Groovy)  
```
```  
  
ClassPathXmlApplicationContext 的利用思路很常见了, 在 PostgreSQL JDBC RCE 和 ActiveMQ RCE 中都出现过  
  
需要找到一个能够调用构造函数的静态方法, 即通过 invokeConstructor 实例化 ClassPathXmlApplicationContext 加载 XML 实现 RCE  
  
org.apache.commons.beanutils.ConstructorUtils#invokeConstructor(java.lang.Class<T>, java.lang.Object)  
```
```  
  
还是得注意一个点, 前面说过 H2 不支持 JAVA_OBJECT 与 VARCHAR (CHARACTER VARYING) 之间的类型转换, 因此直接将 XML URL 传入 INVOKE_CONSTRUCTOR 会报错, 因为对应的 invokeConstructor 的第二个参数的类型为 java.lang.Object, 即 JAVA_OBJECT, 而 H2 字符串的类型为 VARCHAR (CHARACTER VARYING)  
  
解决方法是通过一系列的反射操作拿到一个类型为 java.lang.Object 的对象 (实际上仍然为 java.lang.String)  
  
这里我的思路是利用 URI.create 静态方法, 返回一个 URI 对象  
  
![](https://mmbiz.qpic.cn/mmbiz_png/7nIrJAgaibicNp3ricpkY8BOGRSISbKiaykqzwalLcVr7bgoGhpRyoicE40xU1IT8KicaJn28icW8Aa8icC4PE0NT5qtUw/640?wx_fmt=png&from=appmsg "")  
  
然后通过 INVOKE_METHOD 调用其 toString 方法, 这样由于 invokeMethod 方法签名的原因, 会使得最终返回的对象被 H2 认为是 JAVA_OBJECT 类型  
  
最后再将这个对象作为参数传入 INVOKE_CONSTRUCTOR 即可成功实例化 ClassPathXmlApplicationContext 实现 RCE  
  
利用流程跟前面一样  
  
![](https://mmbiz.qpic.cn/mmbiz_png/7nIrJAgaibicNp3ricpkY8BOGRSISbKiaykqUH6xegymRcBBsNYndwCaxAnwv2xEtt6FJS4d9onDNpH935gPkn06zw/640?wx_fmt=png&from=appmsg "")  
  
来源：【https://xz.aliyun.com/】，感谢【  
X1r0z  
】  
  
![](https://mmbiz.qpic.cn/mmbiz_jpg/7nIrJAgaibicNp3ricpkY8BOGRSISbKiaykqzdzJ12W5Eyxa4HlPlmkYiaLnAHsZvePw3oYrLI1XT8teibux1J86IV5A/640?wx_fmt=jpeg&from=appmsg "")  
  
由于群已经满了，各位大佬有兴趣可以加浪师父微信，再进群。  
  
![](https://mmbiz.qpic.cn/mmbiz_jpg/7nIrJAgaibicNp3ricpkY8BOGRSISbKiaykqtTb8n5GIahZicUdVqwRNiaVxgeqzXruMn8IUS0Hya5lHyriaugPZokWhg/640?wx_fmt=jpeg&from=appmsg "")  
  
  
